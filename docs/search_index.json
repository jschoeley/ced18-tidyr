[
["index.html", "Tidy R Chapter 1 Before we start", " Tidy R Jonas Schöley 2018-07-16 Chapter 1 Before we start These are the packages we will use during this course. install.packages(&#39;devtools&#39;) devtools::install_cran( pkgs = c( &#39;tidyverse&#39;, # tools for tidy data analysis &#39;rmarkdown&#39;, # literate programming &#39;plotly&#39;, # interactive visualization &#39;ggmap&#39;, # use online map-tiles with ggplot &#39;eurostat&#39;, # download data from eurostat &#39;sf&#39;, # tidy geo-computing &#39;rnaturalearth&#39;, # download worldwide map data &#39;gapminder&#39;, # data from the gapminder world project &#39;cowplot&#39;, # ggplot multiple figures addon &#39;skimr&#39; # nice dataframe summaries ), repos = &quot;https://cran.rstudio.com/&quot; ) "],
["what-is-tidy-r.html", "Chapter 2 What is tidy R? 2.1 Differences between tidy and base R 2.2 Literate programming in Rmarkdown 2.3 First steps in tidy data analysis", " Chapter 2 What is tidy R? 2.1 Differences between tidy and base R The Gompertz Law describes the exponential relationship between age and mortality rate in human populations. Its two parameters \\(a\\) and \\(b\\) describe the overall mortality level and the relative rate of mortality inrease over age. It is well known that both parameters correlate with each other. The code below demonstrates this co-variance by fitting the Gompertz equation to Swedish birth cohorts and plotting the parameter estimates against each other. \\[ \\mu(x) = ae^{bx} \\] # load data load(&#39;data/hmd/hmd_counts.RData&#39;) # select ages 30 to 80, drop total counts, drop NAs hmd_sub &lt;- na.omit(subset(hmd_counts, age &gt;= 30 &amp; age &lt; 80 &amp; sex != &#39;Total&#39;)) # split the data by sex, country and year hmd_split &lt;- split(hmd_sub, list(hmd_sub$sex, hmd_sub$country, hmd_sub$period), drop = TRUE) # run a linear regression on each subset hmd_regress &lt;- lapply(hmd_split, function (lt) glm(round(nDx, 0) ~ I(age-30) + offset(log(nEx)), family = &#39;poisson&#39;, data = lt)) # extract the coefficients from each regression model hmd_coef &lt;- t(sapply(hmd_regress, coef)) # plot a versus b coefficients plot(x = hmd_coef[,1], y = hmd_coef[,2], main = &#39;Gompertz correlation&#39;, xlab = &#39;a&#39;, ylab = &#39;b&#39;) Here’s how I would write the same program today, using the tidyverse. library(tidyverse) # load data load(&#39;data/hmd/hmd_counts.RData&#39;) hmd_counts %&gt;% # select ages 30 to 80, drop total counts filter(age &gt;= 30, age &lt; 80, sex != &#39;Total&#39;) %&gt;% # drop NAs drop_na() %&gt;% # for each period... group_by(period, country, sex) %&gt;% # ...run a Poisson regression of deaths versus age do(lm = glm(round(nDx, 0) ~ I(age-30) + offset(log(nEx)), family = &#39;poisson&#39;, data = .)) %&gt;% # extract the regression coefficients mutate(a = coef(lm)[1], b = coef(lm)[2]) %&gt;% # plot a versus b coefficients and label with year ggplot() + geom_point(aes(x = a, y = b), shape = 1, size = 3) + labs(title = &#39;Gompertz correlation&#39;) What are the differences? In base R we stores intermediate results often. In tidy R a single data pipeline often gets us from raw data to finished result. In base R data structures change often. In tidy R the dataframe is the most important data structure. In base R we have to use various indexing styles. In tidy R we use a single indexing style. In base R important information is sometimes stored in row names. In tidy R all information exists in the form of data frame columns. 2.1.1 Excercise: Differences between tidy and base R Discuss the differences. 2.2 Literate programming in Rmarkdown The official Rmarkdown cheat sheet. 2.2.1 Excercise: Literate programming in Rmarkdown Rewrite any of your existing R-scripts into an Rmarkdown script. Demonstrate loading data from the hard disc, plot output, text blocks, headers and lists. Export to pdf. 2.3 First steps in tidy data analysis "],
["data-wrangling.html", "Chapter 3 Data Wrangling 3.1 The “tidy” approach to data wrangling 3.2 Transforming data using verbs 3.3 Pipes 3.4 Tidy data 3.5 Joins 3.6 Recoding 3.7 Tidy iteration", " Chapter 3 Data Wrangling library(tidyverse) # General social survey # source: http://gss.norc.org/s gss &lt;- haven::read_stata(&#39;data/gss/GSS2016.DTA&#39;) 3.1 The “tidy” approach to data wrangling “Data wrangling” is the process of transforming raw data into a form fit for analysis. This may include operations like filtering, sorting, joining, splitting, recoding or reshaping, nearly always performed in conjuction with each other. The tidy approach to data wrangling aims to make this often mundane but critical task as clear and fast as possible. Tidy data wrangling revolves around 4 concepts: Verbs A small collection of “verbs” provides basic transformation operations. Pipes Transformations can be chained together via a “pipe”. Tidy Data Everything is a data frame with cases as rows and variables as columns. Tidy iteration Transformations can be repeatedly applied to different row or column subsets without the use of a for loop. 3.2 Transforming data using verbs The tidyverse provides us with an array of verbs for data transformation such as filter(), mutate(), summarise() and many more. While each of those verbs performs a distinct action they all have a common design. All verbs… …have as their first argument a data frame: All verbs operate on data frames only. This is one of the helpful restrictions of the tidyverse because you don’t need to consider data structures beyond the tabular form of a data frame. If your data does not come in a data frame, it needs to be converted. # this fails because &quot;WorldPhones&quot; is a matrix and not a data frame select(WorldPhones, 3) ## Error in UseMethod(&quot;select_&quot;): no applicable method for &#39;select_&#39; applied to an object of class &quot;c(&#39;matrix&#39;, &#39;double&#39;, &#39;numeric&#39;)&quot; # converting World Phones to a data frame resolves the issue select(as.data.frame(WorldPhones), 3) ## Asia ## 1951 2876 ## 1956 4708 ## 1957 5230 ## 1958 6662 ## 1959 6856 ## 1960 8220 ## 1961 9053 The data frame to operate on is always the first argument in any of the verb functions. Here we select() the first variable of the data frame hmd_counts. # hmd_counts # Deaths and exposures by age, year, sex and country # source: Human Mortality Database load(&#39;data/hmd/hmd_counts.RData&#39;) select(hmd_counts, 1) ## # A tibble: 1,304,694 x 1 ## country ## &lt;chr&gt; ## 1 AUS ## 2 AUS ## 3 AUS ## 4 AUS ## 5 AUS ## # ... with 1.305e+06 more rows Due to the data frame always coming first we can use the %&gt;% (pipe) operator to pass data into any of the verbs. hmd_counts %&gt;% select(1) ## # A tibble: 1,304,694 x 1 ## country ## &lt;chr&gt; ## 1 AUS ## 2 AUS ## 3 AUS ## 4 AUS ## 5 AUS ## # ... with 1.305e+06 more rows …don’t change the data frame unless you explicitly want to Note that none of the verbs permanently change the content of a data frame. You need to assign the output of a verb to an object in order to permanently store your computations. # display the result of rename() without changing the data rename(hmd_counts, deaths = nDx, exposures = nEx) ## # A tibble: 1,304,694 x 7 ## country sex period age nx deaths exposures ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUS Female 1921 0 1 3842. 64052. ## 2 AUS Female 1921 1 1 719. 59619. ## 3 AUS Female 1921 2 1 330. 57126. ## 4 AUS Female 1921 3 1 166. 57484. ## 5 AUS Female 1921 4 1 190. 58407. ## # ... with 1.305e+06 more rows hmd_counts ## # A tibble: 1,304,694 x 7 ## country sex period age nx nDx nEx ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUS Female 1921 0 1 3842. 64052. ## 2 AUS Female 1921 1 1 719. 59619. ## 3 AUS Female 1921 2 1 330. 57126. ## 4 AUS Female 1921 3 1 166. 57484. ## 5 AUS Female 1921 4 1 190. 58407. ## # ... with 1.305e+06 more rows # permanently store the results of rename() in a new object called `hmd_counts_new` hmd_counts_new &lt;- rename(hmd_counts, deaths = nDx, exposures = nEx) hmd_counts_new ## # A tibble: 1,304,694 x 7 ## country sex period age nx deaths exposures ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUS Female 1921 0 1 3842. 64052. ## 2 AUS Female 1921 1 1 719. 59619. ## 3 AUS Female 1921 2 1 330. 57126. ## 4 AUS Female 1921 3 1 166. 57484. ## 5 AUS Female 1921 4 1 190. 58407. ## # ... with 1.305e+06 more rows …let you address columns within the data frame by simply typing the name The tidyverse functions always work within the context of a data frame – specified as first argument – and columns within that data frame can be adressed by simply typing their name (without quotes). # this returns life-tables entries for Australia, 1921 ages 20 to 25 filter(hmd_counts, country == &#39;AUS&#39;, period == 1921, age %in% 20:25) ## # A tibble: 18 x 7 ## country sex period age nx nDx nEx ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUS Female 1921 20 1 138. 46387. ## 2 AUS Female 1921 21 1 118. 46437. ## 3 AUS Female 1921 22 1 116. 45769. ## 4 AUS Female 1921 23 1 149. 45746. ## 5 AUS Female 1921 24 1 146. 46524. ## # ... with 13 more rows # this is the same, but much more cumbersome to write and read hmd_counts[hmd_counts$country == &#39;AUS&#39; &amp; hmd_counts$period == 1921 &amp; hmd_counts$age %in% 20:25,] ## # A tibble: 18 x 7 ## country sex period age nx nDx nEx ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUS Female 1921 20 1 138. 46387. ## 2 AUS Female 1921 21 1 118. 46437. ## 3 AUS Female 1921 22 1 116. 45769. ## 4 AUS Female 1921 23 1 149. 45746. ## 5 AUS Female 1921 24 1 146. 46524. ## # ... with 13 more rows …output a data frame 3.2.1 Column based transforms 3.2.1.1 mutate() columns mutate() adds a column to a data frame or changes an existing column. hmd_counts %&gt;% # calculate new column with death rates from # columns nDx and nEx mutate(nmx = nDx/nEx) ## # A tibble: 1,304,694 x 8 ## country sex period age nx nDx nEx nmx ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUS Female 1921 0 1 3842. 64052. 0.0600 ## 2 AUS Female 1921 1 1 719. 59619. 0.0121 ## 3 AUS Female 1921 2 1 330. 57126. 0.00578 ## 4 AUS Female 1921 3 1 166. 57484. 0.00289 ## 5 AUS Female 1921 4 1 190. 58407. 0.00325 ## # ... with 1.305e+06 more rows hmd_counts %&gt;% # change unit of exposure variable from person-years # to person months mutate(nEx = nEx*12) ## # A tibble: 1,304,694 x 7 ## country sex period age nx nDx nEx ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUS Female 1921 0 1 3842. 768626. ## 2 AUS Female 1921 1 1 719. 715431. ## 3 AUS Female 1921 2 1 330. 685512. ## 4 AUS Female 1921 3 1 166. 689806. ## 5 AUS Female 1921 4 1 190. 700884. ## # ... with 1.305e+06 more rows Within a single mutate() statement multiple new variables can be created. hmd_counts %&gt;% mutate( # add discrete age variable age_group = cut(age, seq(0, 90, 10), include.lowest = TRUE), # add mortality rate nmx = nDx/nEx ) ## # A tibble: 1,304,694 x 9 ## country sex period age nx nDx nEx age_group nmx ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 AUS Female 1921 0 1 3842. 64052. [0,10] 0.0600 ## 2 AUS Female 1921 1 1 719. 59619. [0,10] 0.0121 ## 3 AUS Female 1921 2 1 330. 57126. [0,10] 0.00578 ## 4 AUS Female 1921 3 1 166. 57484. [0,10] 0.00289 ## 5 AUS Female 1921 4 1 190. 58407. [0,10] 0.00325 ## # ... with 1.305e+06 more rows Newly created variables can immediately be used in the creation of additional variables. hmd_counts %&gt;% mutate( nmx = nDx/nEx, # convert death rates to death probability nqx = 1-exp(-nmx), # and survival probability npx = 1-nqx ) ## # A tibble: 1,304,694 x 10 ## country sex period age nx nDx nEx nmx nqx npx ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUS Female 1921 0 1 3842. 64052. 0.0600 0.0582 0.942 ## 2 AUS Female 1921 1 1 719. 59619. 0.0121 0.0120 0.988 ## 3 AUS Female 1921 2 1 330. 57126. 0.00578 0.00576 0.994 ## 4 AUS Female 1921 3 1 166. 57484. 0.00289 0.00288 0.997 ## 5 AUS Female 1921 4 1 190. 58407. 0.00325 0.00325 0.997 ## # ... with 1.305e+06 more rows 3.2.1.2 select() columns Using select() we can specify which columns to keep and which columns to delete from a data frame. Let’s have a look at a typical panel data set: The General Social Survey. We can see that the gss data features 960 columns. # General social survey # source: http://gss.norc.org/s gss &lt;- haven::read_stata(&#39;data/gss/GSS2016.DTA&#39;) gss ## # A tibble: 2,867 x 960 ## mar1 mar2 mar3 mar4 mar5 mar6 mar7 mar8 mar9 mar10 mar11 mar12 ## &lt;dbl+&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 5 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 4 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 1 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 1 1 5 4 5 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 5 1 1 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## # ... with 2,862 more rows, and 948 more variables: mar13 &lt;dbl+lbl&gt;, ## # mar14 &lt;dbl+lbl&gt;, abany &lt;dbl+lbl&gt;, abdefect &lt;dbl+lbl&gt;, ## # abhlth &lt;dbl+lbl&gt;, … Here we just select the two columns named id and age. gss %&gt;% select(id, age) ## # A tibble: 2,867 x 2 ## id age ## &lt;dbl&gt; &lt;dbl+lbl&gt; ## 1 1 47 ## 2 2 61 ## 3 3 72 ## 4 4 43 ## 5 5 55 ## # ... with 2,862 more rows We can also select by column position. gss %&gt;% select(312, 28) ## # A tibble: 2,867 x 2 ## id age ## &lt;dbl&gt; &lt;dbl+lbl&gt; ## 1 1 47 ## 2 2 61 ## 3 3 72 ## 4 4 43 ## 5 5 55 ## # ... with 2,862 more rows The column operator : selects a range of columns. We can use it to select all variables from mar1 to mar14, the marriage status of up to 14 persons in a household. gss %&gt;% select(mar1:mar14) ## # A tibble: 2,867 x 14 ## mar1 mar2 mar3 mar4 mar5 mar6 mar7 mar8 mar9 mar10 mar11 mar12 ## &lt;dbl+&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 5 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 4 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 1 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 1 1 5 4 5 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 5 1 1 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## # ... with 2,862 more rows, and 2 more variables: mar13 &lt;dbl+lbl&gt;, ## # mar14 &lt;dbl+lbl&gt; Again, the same is possible by specifying the column position, in this case the first 14 columns. gss %&gt;% select(1:14) ## # A tibble: 2,867 x 14 ## mar1 mar2 mar3 mar4 mar5 mar6 mar7 mar8 mar9 mar10 mar11 mar12 ## &lt;dbl+&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 5 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 4 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 1 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 1 1 5 4 5 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 5 1 1 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## # ... with 2,862 more rows, and 2 more variables: mar13 &lt;dbl+lbl&gt;, ## # mar14 &lt;dbl+lbl&gt; A minus preceeding a selection returns all columns apart from those specified. Notice that a selection of columns like mar1:mar14 must be surrounded by parantheses in order to be removed. # select everything apart from mar1 gss %&gt;% select(-mar1) ## # A tibble: 2,867 x 959 ## mar2 mar3 mar4 mar5 mar6 mar7 mar8 mar9 mar10 mar11 mar12 mar13 ## &lt;dbl+&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 5 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 1 5 4 5 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 5 1 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## # ... with 2,862 more rows, and 947 more variables: mar14 &lt;dbl+lbl&gt;, ## # abany &lt;dbl+lbl&gt;, abdefect &lt;dbl+lbl&gt;, abhlth &lt;dbl+lbl&gt;, ## # abnomore &lt;dbl+lbl&gt;, … # select everything apart from mar1 to mar14 gss %&gt;% select(-(mar1:mar14)) ## # A tibble: 2,867 x 946 ## abany abdefect abhlth abnomore abpoor abrape absingle acqntsex adforjob ## &lt;dbl+&gt; &lt;dbl+lb&gt; &lt;dbl+&gt; &lt;dbl+lb&gt; &lt;dbl+&gt; &lt;dbl+&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; ## 1 1 1 1 1 1 1 1 &lt;NA&gt; &lt;NA&gt; ## 2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 2 &lt;NA&gt; ## 3 2 2 1 2 2 1 2 &lt;NA&gt; &lt;NA&gt; ## 4 2 2 1 2 2 1 2 &lt;NA&gt; &lt;NA&gt; ## 5 1 1 1 1 1 1 1 &lt;NA&gt; &lt;NA&gt; ## # ... with 2,862 more rows, and 937 more variables: adults &lt;dbl+lbl&gt;, ## # advfront &lt;dbl+lbl&gt;, advsched &lt;dbl+lbl&gt;, affrmact &lt;dbl+lbl&gt;, ## # age &lt;dbl+lbl&gt;, … You can use functions inside of select() as long as they return either a column name or a column position. The standard R function which() is handy in that context as it returns the index of the elements for which a conditions holds true. # return all columns of gss which names are 3 characters or less gss %&gt;% select(which(str_length(names(.)) &lt;= 3)) ## # A tibble: 2,867 x 6 ## age god id jew sex tax ## &lt;dbl+lbl&gt; &lt;dbl+lbl&gt; &lt;dbl&gt; &lt;dbl+lbl&gt; &lt;dbl+lbl&gt; &lt;dbl+lbl&gt; ## 1 47 2 1 &lt;NA&gt; 1 2 ## 2 61 &lt;NA&gt; 2 &lt;NA&gt; 1 &lt;NA&gt; ## 3 72 6 3 &lt;NA&gt; 1 1 ## 4 43 6 4 &lt;NA&gt; 2 1 ## 5 55 1 5 &lt;NA&gt; 2 1 ## # ... with 2,862 more rows There are a number of functions provided by the tidyverse which are designed to help with column selection. # select all columns where name starts with &#39;age&#39; gss %&gt;% select(starts_with(&#39;age&#39;)) ## # A tibble: 2,867 x 6 ## age age3 aged agedchld agedpar agekdbrn ## &lt;dbl+lbl&gt; &lt;dbl+lbl&gt; &lt;dbl+lbl&gt; &lt;dbl+lbl&gt; &lt;dbl+lbl&gt; &lt;dbl+lbl&gt; ## 1 47 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 3 29 ## 2 61 &lt;NA&gt; 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 72 &lt;NA&gt; 1 &lt;NA&gt; &lt;NA&gt; 24 ## 4 43 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 1 19 ## 5 55 &lt;NA&gt; 1 &lt;NA&gt; &lt;NA&gt; 31 ## # ... with 2,862 more rows # select columns named mar1, mar2, mar3, mar4, mar5 gss %&gt;% select(num_range(&#39;mar&#39;, 1:5)) ## # A tibble: 2,867 x 5 ## mar1 mar2 mar3 mar4 mar5 ## &lt;dbl+lbl&gt; &lt;dbl+lbl&gt; &lt;dbl+lbl&gt; &lt;dbl+lbl&gt; &lt;dbl+lbl&gt; ## 1 1 1 5 5 &lt;NA&gt; ## 2 4 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 1 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 1 1 5 4 5 ## 5 1 1 5 &lt;NA&gt; &lt;NA&gt; ## # ... with 2,862 more rows # select all columns where name contains &#39;sex&#39; gss %&gt;% select(contains(&#39;sex&#39;)) ## # A tibble: 2,867 x 17 ## acqntsex frndsex homosex intsex matesex othersex paidsex pikupsex ## &lt;dbl+lbl&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; ## 1 &lt;NA&gt; &lt;NA&gt; 4 2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 2 1 &lt;NA&gt; 2 2 2 2 2 ## 3 &lt;NA&gt; &lt;NA&gt; 4 2 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 &lt;NA&gt; &lt;NA&gt; 4 2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 5 &lt;NA&gt; &lt;NA&gt; 4 2 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## # ... with 2,862 more rows, and 9 more variables: relatsex &lt;dbl+lbl&gt;, ## # sex &lt;dbl+lbl&gt;, sexeduc &lt;dbl+lbl&gt;, sexfreq &lt;dbl+lbl&gt;, ## # sexornt &lt;dbl+lbl&gt;, … You can also use regular expressions when selecting columns. # select columns where the name contains a number gss %&gt;% select(matches(&#39;[0-9]&#39;)) ## # A tibble: 2,867 x 323 ## mar1 mar2 mar3 mar4 mar5 mar6 mar7 mar8 mar9 mar10 mar11 mar12 ## &lt;dbl+&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 5 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 4 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 1 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 1 1 5 4 5 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 5 1 1 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## # ... with 2,862 more rows, and 311 more variables: mar13 &lt;dbl+lbl&gt;, ## # mar14 &lt;dbl+lbl&gt;, age3 &lt;dbl+lbl&gt;, artatt1 &lt;dbl+lbl&gt;, artatt2 &lt;dbl+lbl&gt;, ## # … select() returns the columns in the order it selects them. It can therefore be used to reorder the columns of a dataframe. # reverse the order of the columns gss %&gt;% select(rev(names(.))) ## # A tibble: 2,867 x 960 ## cogradtounder cobarate coeftotlt cosector spgradtounder spbarate ## &lt;dbl+lbl&gt; &lt;dbl+lbl&gt; &lt;dbl+lbl&gt; &lt;dbl+lbl&gt; &lt;dbl+lbl&gt; &lt;dbl+lbl&gt; ## 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 2 3 ## 2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 1 1 ## # ... with 2,862 more rows, and 954 more variables: speftotlt &lt;dbl+lbl&gt;, ## # spsector &lt;dbl+lbl&gt;, gradtounder &lt;dbl+lbl&gt;, barate &lt;dbl+lbl&gt;, ## # eftotlt &lt;dbl+lbl&gt;, … # reorder the columns in reverse alphabetical order gss %&gt;% select(order(names(.), decreasing = TRUE)) ## # A tibble: 2,867 x 960 ## zodiac year xnorcsiz xmovie xmarsex xhaustn wwwmin wwwhr wtssnr wtssall ## &lt;dbl+&gt; &lt;dbl&gt; &lt;dbl+lb&gt; &lt;dbl+&gt; &lt;dbl+l&gt; &lt;dbl+l&gt; &lt;dbl+&gt; &lt;dbl&gt; &lt;dbl+&gt; &lt;dbl+l&gt; ## 1 11 2016 6 &lt;NA&gt; 2 &lt;NA&gt; 0 15 1.260… 0.9569… ## 2 8 2016 6 2 &lt;NA&gt; &lt;NA&gt; 0 5 0.630… 0.4784… ## 3 12 2016 6 2 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 1.260… 0.9569… ## 4 4 2016 6 &lt;NA&gt; 1 &lt;NA&gt; 0 7 2.520… 1.9139… ## 5 8 2016 6 2 1 3 &lt;NA&gt; &lt;NA&gt; 1.890… 1.4354… ## # ... with 2,862 more rows, and 950 more variables: wtss &lt;dbl+lbl&gt;, ## # wrkwayup &lt;dbl+lbl&gt;, wrkstat &lt;dbl+lbl&gt;, wrkslf &lt;dbl+lbl&gt;, ## # wrkshift &lt;dbl+lbl&gt;, … # reorder the columns in increasing length of their names gss %&gt;% select(order(str_length(names(.)))) ## # A tibble: 2,867 x 960 ## id age god jew sex tax mar1 mar2 mar3 mar4 mar5 mar6 ## &lt;dbl&gt; &lt;dbl+&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 47 2 &lt;NA&gt; 1 2 1 1 5 5 &lt;NA&gt; &lt;NA&gt; ## 2 2 61 &lt;NA&gt; &lt;NA&gt; 1 &lt;NA&gt; 4 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 3 72 6 &lt;NA&gt; 1 1 1 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 4 43 6 &lt;NA&gt; 2 1 1 1 5 4 5 5 ## 5 5 55 1 &lt;NA&gt; 2 1 1 1 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## # ... with 2,862 more rows, and 948 more variables: mar7 &lt;dbl+lbl&gt;, ## # mar8 &lt;dbl+lbl&gt;, mar9 &lt;dbl+lbl&gt;, age3 &lt;dbl+lbl&gt;, aged &lt;dbl+lbl&gt;, … # reorder the columns randomly gss %&gt;% select(sample(ncol(.))) ## # A tibble: 2,867 x 960 ## frndsex colcom gender3 fund16 old4 cojew balpos relhh12 brlawfl wordh ## &lt;dbl+lb&gt; &lt;dbl+l&gt; &lt;dbl+l&gt; &lt;dbl+&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl+&gt; &lt;dbl+l&gt; &lt;dbl+l&gt; &lt;dbl&gt; ## 1 &lt;NA&gt; 5 1 2 15 &lt;NA&gt; 1 &lt;NA&gt; 2 1 ## 2 1 &lt;NA&gt; &lt;NA&gt; 2 &lt;NA&gt; &lt;NA&gt; 1 &lt;NA&gt; 3 0 ## 3 &lt;NA&gt; 4 &lt;NA&gt; 2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 &lt;NA&gt; 5 1 2 21 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 3 &lt;NA&gt; ## 5 &lt;NA&gt; 5 2 3 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## # ... with 2,862 more rows, and 950 more variables: agedchld &lt;dbl+lbl&gt;, ## # uscitzn &lt;dbl+lbl&gt;, marital &lt;dbl+lbl&gt;, wtssall &lt;dbl+lbl&gt;, ## # ethnum &lt;dbl+lbl&gt;, … Selected columns can be renamed. gss %&gt;% select(ID = id, EDUCATION = educ) ## # A tibble: 2,867 x 2 ## ID EDUCATION ## &lt;dbl&gt; &lt;dbl+lbl&gt; ## 1 1 16 ## 2 2 12 ## 3 3 16 ## 4 4 12 ## 5 5 18 ## # ... with 2,862 more rows 3.2.1.3 rename() columns There’s not much to rename(). We use it to change the names of the columns in a dataframe. Unlike select(), which can also change names, rename() keeps all columns. We write new_column_name = old_column_name. hmd_counts %&gt;% rename(Age = age, Exposure = nEx, Deaths = nDx) ## # A tibble: 1,304,694 x 7 ## country sex period Age nx Deaths Exposure ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUS Female 1921 0 1 3842. 64052. ## 2 AUS Female 1921 1 1 719. 59619. ## 3 AUS Female 1921 2 1 330. 57126. ## 4 AUS Female 1921 3 1 166. 57484. ## 5 AUS Female 1921 4 1 190. 58407. ## # ... with 1.305e+06 more rows If we want to use spaces in the column names (not recomended though) we have to surround the new name with `backticks`. hmd_counts %&gt;% rename(`Person-years exposure` = nEx, `Number of deaths` = nDx) ## # A tibble: 1,304,694 x 7 ## country sex period age nx `Number of deaths` `Person-years expo… ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUS Female 1921 0 1 3842. 64052. ## 2 AUS Female 1921 1 1 719. 59619. ## 3 AUS Female 1921 2 1 330. 57126. ## 4 AUS Female 1921 3 1 166. 57484. ## 5 AUS Female 1921 4 1 190. 58407. ## # ... with 1.305e+06 more rows 3.2.2 Row based transforms 3.2.2.1 filter() rows You can create subsets of the rows in your data using filter(). # euro_regio # European regional population statistics load(&#39;data/euro_regio/euro_regio.Rdata&#39;) # return rows of `euro_regio` where year is equal to 2016 euro_regio %&gt;% filter(year == 2016) ## # A tibble: 342 x 21 ## country_code country_name nuts2_code nuts2_name year pop popdens ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AL Albania AL01 Veri 2016 848059 NA ## 2 AL Albania AL02 Qender 2016 1110562 NA ## 3 AL Albania AL03 Jug 2016 927405 NA ## 4 AL Albania ALXX ALXX Not reg… 2016 NA NA ## 5 AT Austria AT11 Burgenland (… 2016 291011 77.1 ## # ... with 337 more rows, and 14 more variables: births &lt;dbl&gt;, ## # deaths &lt;dbl&gt;, natgrowthrate &lt;dbl&gt;, growthrate &lt;dbl&gt;, netmigrate &lt;dbl&gt;, ## # … In filter() you specify logical tests which are evaluated for each row. If the condition evaluates to TRUE for a row, the row is returned, if it evaluates to FALSE the row is not returned. A row is also not returned if the condition evaluates to NA Multiple filtering conditions are separated by a comma. The comma acts as a logical “AND”, i.e. the &amp; operator, which only returns TRUE if all the conditions are TRUE. # return rows where year is equal to 2016 and region is Catalonia euro_regio %&gt;% filter(year == 2016, nuts2_code == &#39;ES51&#39;) ## # A tibble: 1 x 21 ## country_code country_name nuts2_code nuts2_name year pop popdens ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ES Spain ES51 Cataluña 2016 7408290 232. ## # ... with 14 more variables: births &lt;dbl&gt;, deaths &lt;dbl&gt;, ## # natgrowthrate &lt;dbl&gt;, growthrate &lt;dbl&gt;, netmigrate &lt;dbl&gt;, … # this is the same as above euro_regio %&gt;% filter(year == 2016 &amp; nuts2_code == &#39;ES51&#39;) ## # A tibble: 1 x 21 ## country_code country_name nuts2_code nuts2_name year pop popdens ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ES Spain ES51 Cataluña 2016 7408290 232. ## # ... with 14 more variables: births &lt;dbl&gt;, deaths &lt;dbl&gt;, ## # natgrowthrate &lt;dbl&gt;, growthrate &lt;dbl&gt;, netmigrate &lt;dbl&gt;, … All of R’s logical operators can be used in filter() as well. You use &lt;, &gt;, &gt;=, &lt;= for magnitude comparisons. # is 1,2,3,4 larger than 1? 1:4 &gt; 1 ## [1] FALSE TRUE TRUE TRUE # return all rows where unemployment is higher than 30% euro_regio %&gt;% filter(unemp &gt; 30) ## # A tibble: 27 x 21 ## country_code country_name nuts2_code nuts2_name year pop popdens ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 EL Greece EL52 Kentriki Make… 2013 1.91e6 99.6 ## 2 EL Greece EL53 Dytiki Makedo… 2013 2.81e5 29.6 ## 3 EL Greece EL53 Dytiki Makedo… 2015 2.76e5 29.1 ## 4 EL Greece EL53 Dytiki Makedo… 2016 2.74e5 29.5 ## 5 ES Spain ES43 Extremadura 2012 1.10e6 27.1 ## # ... with 22 more rows, and 14 more variables: births &lt;dbl&gt;, ## # deaths &lt;dbl&gt;, natgrowthrate &lt;dbl&gt;, growthrate &lt;dbl&gt;, netmigrate &lt;dbl&gt;, ## # … # is 1,2,3,4 smaller than 1? 1:4 &lt; 1 ## [1] FALSE FALSE FALSE FALSE # return all rows where net-migration rate is lower than -20% euro_regio %&gt;% filter(netmigrate &lt; -20) ## # A tibble: 13 x 21 ## country_code country_name nuts2_code nuts2_name year pop popdens ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 LT Lithuania LT00 Lietuva (NUTS… 2010 3.14e6 49.4 ## 2 TR Turkey TR33 Manisa, Afyon… 2011 3.01e6 66.5 ## 3 TR Turkey TR81 Zonguldak, Ka… 2011 1.04e6 108. ## 4 TR Turkey TRA1 Erzurum, Erzi… 2013 1.07e6 26.2 ## 5 TR Turkey TRA2 Agri, Kars, I… 2009 1.14e6 37.9 ## # ... with 8 more rows, and 14 more variables: births &lt;dbl&gt;, deaths &lt;dbl&gt;, ## # natgrowthrate &lt;dbl&gt;, growthrate &lt;dbl&gt;, netmigrate &lt;dbl&gt;, … # is 1,2,3,4 smaller or equal to 1? 1:4 &lt;= 1 ## [1] TRUE FALSE FALSE FALSE # return all rows where life-expectancy is 75 years or less euro_regio %&gt;% filter(lifeexp &lt;= 75) ## # A tibble: 274 x 21 ## country_code country_name nuts2_code nuts2_name year pop popdens ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BG Bulgaria BG31 Severozapaden 2005 NA 49.5 ## 2 BG Bulgaria BG31 Severozapaden 2006 934755 48.5 ## 3 BG Bulgaria BG31 Severozapaden 2007 916308 47.6 ## 4 BG Bulgaria BG31 Severozapaden 2008 898371 46.7 ## 5 BG Bulgaria BG31 Severozapaden 2009 881573 45.8 ## # ... with 269 more rows, and 14 more variables: births &lt;dbl&gt;, ## # deaths &lt;dbl&gt;, natgrowthrate &lt;dbl&gt;, growthrate &lt;dbl&gt;, netmigrate &lt;dbl&gt;, ## # … # is 1,2,3,4 greater than or equal to 1? 1:4 &gt;= 1 ## [1] TRUE TRUE TRUE TRUE # return all rows where life-expectancy is 85 years or more euro_regio %&gt;% filter(lifeexp &gt;= 85) ## # A tibble: 2 x 21 ## country_code country_name nuts2_code nuts2_name year pop popdens ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 CH Switzerland CH07 Ticino 2016 3.52e5 129. ## 2 ES Spain ES30 Comunidad de … 2016 6.42e6 809. ## # ... with 14 more variables: births &lt;dbl&gt;, deaths &lt;dbl&gt;, ## # natgrowthrate &lt;dbl&gt;, growthrate &lt;dbl&gt;, netmigrate &lt;dbl&gt;, … Boolean logic is implemented via &amp; (and), | (or), and xor() (exclusive or). # is 1,2,3,4 greater than 1 AND is 1,2,3,4 smaller than 1? (1:4 &gt; 1) &amp; (1:4 &lt; 1) ## [1] FALSE FALSE FALSE FALSE # return all rows where unempolyment is higher than 15% and # netmigration is lower than -15% euro_regio %&gt;% filter(unemp &gt; 15, netmigrate &lt; -15) ## # A tibble: 6 x 21 ## country_code country_name nuts2_code nuts2_name year pop popdens ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 CY Cyprus CY00 Kypros 2014 8.58e5 92.5 ## 2 LT Lithuania LT00 Lietuva (NUTS… 2010 3.14e6 49.4 ## 3 LV Latvia LV00 Latvija 2009 2.16e6 34.4 ## 4 LV Latvia LV00 Latvija 2010 2.12e6 33.7 ## 5 TR Turkey TRB2 Van, Mus, Bit… 2010 2.01e6 48.5 ## # ... with 1 more row, and 14 more variables: births &lt;dbl&gt;, deaths &lt;dbl&gt;, ## # natgrowthrate &lt;dbl&gt;, growthrate &lt;dbl&gt;, netmigrate &lt;dbl&gt;, … # is 1,2,3,4 greater than 1 OR is 1,2,3,4 smaller than 1? (1:4 &gt; 1) | (1:4 &lt; 1) ## [1] FALSE TRUE TRUE TRUE # return all rows where unempolyment is higher than 15% or # netmigration is lower than -15% euro_regio %&gt;% filter(unemp &gt; 15 | netmigrate &lt; -15) ## # A tibble: 462 x 21 ## country_code country_name nuts2_code nuts2_name year pop popdens ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AL Albania AL01 Veri 2014 NA NA ## 2 AL Albania AL03 Jug 2014 NA NA ## 3 BE Belgium BE10 Région de Br… 2006 1018804 6366. ## 4 BE Belgium BE10 Région de Br… 2007 1031215 6459. ## 5 BE Belgium BE10 Région de Br… 2008 1048491 6575. ## # ... with 457 more rows, and 14 more variables: births &lt;dbl&gt;, ## # deaths &lt;dbl&gt;, natgrowthrate &lt;dbl&gt;, growthrate &lt;dbl&gt;, netmigrate &lt;dbl&gt;, ## # … # is only one of those statements true? # 1,2,3,4 greater than 1; 1,2,3,4 smaller than 5 xor(1:4 &gt; 1, 1:4 &lt; 5) ## [1] TRUE FALSE FALSE FALSE # return all rows where unempolyment is higher than 15% or # netmigration is lower than -15% but not both euro_regio %&gt;% filter(xor(unemp &gt; 15, netmigrate &lt; -15)) ## # A tibble: 404 x 21 ## country_code country_name nuts2_code nuts2_name year pop popdens ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BE Belgium BE10 Région de Bru… 2006 1.02e6 6366. ## 2 BE Belgium BE10 Région de Bru… 2007 1.03e6 6459. ## 3 BE Belgium BE10 Région de Bru… 2008 1.05e6 6575. ## 4 BE Belgium BE10 Région de Bru… 2009 1.07e6 6702. ## 5 BE Belgium BE10 Région de Bru… 2010 1.09e6 6902 ## # ... with 399 more rows, and 14 more variables: births &lt;dbl&gt;, ## # deaths &lt;dbl&gt;, natgrowthrate &lt;dbl&gt;, growthrate &lt;dbl&gt;, netmigrate &lt;dbl&gt;, ## # … The %in% operator lets you filter rows based on membership %in% a set. # is 1,2,3,4 part of the set (2,4) 1:4 %in% c(2,4) ## [1] FALSE TRUE FALSE TRUE # return all rows for Germany, United Kingdom and France euro_regio %&gt;% filter(country_code %in% c(&#39;DE&#39;, &#39;UK&#39;, &#39;FR&#39;)) ## # A tibble: 1,404 x 21 ## country_code country_name nuts2_code nuts2_name year pop popdens ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 DE Germany (until… DE11 Stuttgart 2005 NA 379. ## 2 DE Germany (until… DE11 Stuttgart 2006 4007373 380. ## 3 DE Germany (until… DE11 Stuttgart 2007 4005380 380. ## 4 DE Germany (until… DE11 Stuttgart 2008 4007095 380. ## 5 DE Germany (until… DE11 Stuttgart 2009 4006313 379. ## # ... with 1,399 more rows, and 14 more variables: births &lt;dbl&gt;, ## # deaths &lt;dbl&gt;, natgrowthrate &lt;dbl&gt;, growthrate &lt;dbl&gt;, netmigrate &lt;dbl&gt;, ## # … You can use any combination of functions within filter() as long as they return a logical vector as long as the input data frame. This makes it possible to… # ... return the region with the highest population count in 2015 euro_regio %&gt;% filter(year == 2015) %&gt;% filter(pop == max(pop, na.rm = TRUE)) ## # A tibble: 1 x 21 ## country_code country_name nuts2_code nuts2_name year pop popdens ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 TR Turkey TR10 Istanbul 2015 14377018 2794. ## # ... with 14 more variables: births &lt;dbl&gt;, deaths &lt;dbl&gt;, ## # natgrowthrate &lt;dbl&gt;, growthrate &lt;dbl&gt;, netmigrate &lt;dbl&gt;, … # ... return the regions with the lowest per head income in 2015, ranks 1 to 3 euro_regio %&gt;% filter(year == 2015) %&gt;% filter(min_rank(income) &lt;= 3) ## # A tibble: 3 x 21 ## country_code country_name nuts2_code nuts2_name year pop popdens ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BG Bulgaria BG31 Severozapaden 2015 7.97e5 42.5 ## 2 BG Bulgaria BG42 Yuzhen tsentr… 2015 1.45e6 66 ## 3 FR France FRA5 Mayotte (NUTS… 2015 2.30e5 628. ## # ... with 14 more variables: births &lt;dbl&gt;, deaths &lt;dbl&gt;, ## # natgrowthrate &lt;dbl&gt;, growthrate &lt;dbl&gt;, netmigrate &lt;dbl&gt;, … # ... return the regions with the highest per head income in 2015, ranks 1 to 3 euro_regio %&gt;% filter(year == 2015) %&gt;% filter(min_rank(desc(income)) &lt;= 3) ## # A tibble: 3 x 21 ## country_code country_name nuts2_code nuts2_name year pop popdens ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 DE Germany (until … DE21 Oberbayern 2015 4.52e6 260. ## 2 LU Luxembourg LU00 Luxembourg 2015 5.63e5 220. ## 3 UK United Kingdom UKI3 Inner Lon… 2015 1.13e6 10469. ## # ... with 14 more variables: births &lt;dbl&gt;, deaths &lt;dbl&gt;, ## # natgrowthrate &lt;dbl&gt;, growthrate &lt;dbl&gt;, netmigrate &lt;dbl&gt;, … # ... return the regions with the highest absolute net-migration rate in 2015, # ranks 1 to 3 euro_regio %&gt;% filter(year == 2015) %&gt;% filter(min_rank(desc(abs(netmigrate))) &lt;= 3) ## # A tibble: 3 x 21 ## country_code country_name nuts2_code nuts2_name year pop popdens ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 DE Germany (until… DEB2 Trier 2015 5.22e5 107. ## 2 MT Malta MT00 Malta 2015 4.40e5 1408. ## 3 TR Turkey TRA2 Agri, Kars… 2015 1.14e6 37.8 ## # ... with 14 more variables: births &lt;dbl&gt;, deaths &lt;dbl&gt;, ## # natgrowthrate &lt;dbl&gt;, growthrate &lt;dbl&gt;, netmigrate &lt;dbl&gt;, … # ... return the &gt;99 percentile regions by life expectancy in 2015 euro_regio %&gt;% filter(year == 2015) %&gt;% filter(cume_dist(lifeexp) &gt;= 0.99) ## # A tibble: 4 x 21 ## country_code country_name nuts2_code nuts2_name year pop popdens ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ES Spain ES22 Comunidad For… 2015 6.36e5 61.6 ## 2 ES Spain ES30 Comunidad de … 2015 6.39e6 804 ## 3 FR France FR10 Île de France 2015 1.21e7 1008. ## 4 IT Italy ITH2 Provincia Aut… 2015 5.37e5 86.6 ## # ... with 14 more variables: births &lt;dbl&gt;, deaths &lt;dbl&gt;, ## # natgrowthrate &lt;dbl&gt;, growthrate &lt;dbl&gt;, netmigrate &lt;dbl&gt;, … Special care has to be taken when filtering NA values. One may be inclined to return all rows including NA in the variable pop by writing euro_regio %&gt;% filter(pop == NA) ## # A tibble: 0 x 21 ## # ... with 21 variables: country_code &lt;chr&gt;, country_name &lt;chr&gt;, ## # nuts2_code &lt;chr&gt;, nuts2_name &lt;chr&gt;, year &lt;int&gt;, … Zero rows are returned because for R NA == NA always returns NA instead of TRUE and filter() does not return rows for which a condition evaluates to NA. If we want to test for NA we must use the function is.na() which returns TRUE whenever an NA is encountered and FALSE otherwise. euro_regio %&gt;% filter(is.na(pop)) ## # A tibble: 683 x 21 ## country_code country_name nuts2_code nuts2_name year pop popdens ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AL Albania AL01 Veri 2005 NA NA ## 2 AL Albania AL01 Veri 2006 NA NA ## 3 AL Albania AL01 Veri 2007 NA NA ## 4 AL Albania AL01 Veri 2008 NA NA ## 5 AL Albania AL01 Veri 2009 NA NA ## # ... with 678 more rows, and 14 more variables: births &lt;dbl&gt;, ## # deaths &lt;dbl&gt;, natgrowthrate &lt;dbl&gt;, growthrate &lt;dbl&gt;, netmigrate &lt;dbl&gt;, ## # … 3.2.2.2 arrange() rows arrange() re-orders the rows of a dataframe according to the values of one or more variables within that dataframe. # eu_timeuse_tot # European timeuse survey # source: Eurostat load(&#39;data/eu_timeuse/eu_timeuse_tot.Rdata&#39;) # order data frame by increasing date eu_timeuse_tot %&gt;% arrange(year) ## # A tibble: 1,671 x 8 ## country_code country_name year activity_code activity_name prtcp_rate ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 BE Belgium 2000 AC0 Personal care 100 ## 2 BE Belgium 2000 AC01 Sleep 100 ## 3 BE Belgium 2000 AC02 Eating 99.5 ## 4 BE Belgium 2000 AC03 Other and/or u… 97.6 ## 5 BE Belgium 2000 AC1_TR Employment, re… 34.5 ## # ... with 1,666 more rows, and 2 more variables: prtcp_time_min &lt;dbl&gt;, ## # time_spent_min &lt;dbl&gt; If multiple variables are specified, the dataframe is re-ordered in the sequence of specification. This behavior makes it possible to design useful tables, i.e. our eu_timeuse data contains the time spent each day on different activities by type of activity, country, and year. Sorting by activity, country and (at last position) year gives a table that allows for quick comparisions along the time axis. Having country last would allow for quick comparisions among coutries and so on. # order data frame by activity, country and year eu_timeuse_tot %&gt;% arrange(activity_name, country_name, year) ## # A tibble: 1,671 x 8 ## country_code country_name year activity_code activity_name prtcp_rate ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 AT Austria 2010 AC1B Activities rel… 22.6 ## 2 BE Belgium 2000 AC1B Activities rel… 1.4 ## 3 BE Belgium 2010 AC1B Activities rel… 12.5 ## 4 BG Bulgaria 2000 AC1B Activities rel… 7.1 ## 5 EE Estonia 2000 AC1B Activities rel… 10.9 ## # ... with 1,666 more rows, and 2 more variables: prtcp_time_min &lt;dbl&gt;, ## # time_spent_min &lt;dbl&gt; # order data frame by activity, year, and country eu_timeuse_tot %&gt;% arrange(activity_name, year, country_name) ## # A tibble: 1,671 x 8 ## country_code country_name year activity_code activity_name prtcp_rate ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 BE Belgium 2000 AC1B Activities rel… 1.4 ## 2 BG Bulgaria 2000 AC1B Activities rel… 7.1 ## 3 EE Estonia 2000 AC1B Activities rel… 10.9 ## 4 FI Finland 2000 AC1B Activities rel… 7.2 ## 5 FR France 2000 AC1B Activities rel… 1.6 ## # ... with 1,666 more rows, and 2 more variables: prtcp_time_min &lt;dbl&gt;, ## # time_spent_min &lt;dbl&gt; By default character variables are ordered in increasing alphabetical order and numeric variables in increasing numerical order. The desc() function allows to reverse that behavior. # order data frame by reverse alphabetical activity, and alphabetical country eu_timeuse_tot %&gt;% arrange(desc(activity_name), country_name) ## # A tibble: 1,671 x 8 ## country_code country_name year activity_code activity_name prtcp_rate ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 AT Austria 2010 AC344 Walking the dog 6.5 ## 2 BE Belgium 2000 AC344 Walking the dog 7.1 ## 3 BE Belgium 2010 AC344 Walking the dog 8.1 ## 4 BG Bulgaria 2000 AC344 Walking the dog 2.2 ## 5 EE Estonia 2000 AC344 Walking the dog 8.5 ## # ... with 1,666 more rows, and 2 more variables: prtcp_time_min &lt;dbl&gt;, ## # time_spent_min &lt;dbl&gt; 3.2.2.3 slice() rows #random shuffle gss %&gt;% slice(sample(1:n())) ## # A tibble: 2,867 x 960 ## mar1 mar2 mar3 mar4 mar5 mar6 mar7 mar8 mar9 mar10 mar11 mar12 ## &lt;dbl+&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 5 1 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 3 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 1 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 5 1 1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## # ... with 2,862 more rows, and 948 more variables: mar13 &lt;dbl+lbl&gt;, ## # mar14 &lt;dbl+lbl&gt;, abany &lt;dbl+lbl&gt;, abdefect &lt;dbl+lbl&gt;, ## # abhlth &lt;dbl+lbl&gt;, … 3.2.3 Excercise: Basic verbs Fix the following code: hmd_counts %&gt;% filter(country = &#39;AUS&#39;, age = &#39;0&#39;, sex = &#39;Female&#39;) %&gt;% mutate(hmd_counts, period_width = diff(period)) #hmd_counts %&gt;% # filter(country == &#39;AUS&#39;, age == 0, sex == &#39;Female&#39;) %&gt;% # mutate(period_width = c(diff(period), NA)) gss %&gt;% filter(bigbang == NA) #gss %&gt;% filter(is.na(NA)) Filter hmd_counts such that it contains all Swedish life-tables and only life-tables for years 2000+ for countries other than Sweden. Why do the results differ? euro_regio %&gt;% filter(year == 2015, rank(-income) &lt;= 3) euro_regio %&gt;% filter(year == 2015) %&gt;% filter(rank(-income) &lt;= 3) With gss select the first 10 columns the last 10 columns every 5th column from 1 to 100 every column where the name does not contain a number all columns where the names contain a phrase of your choice 3.3 Pipes We can chain multiple function and transformations steps into a data analysis pipeline. This is a great approach for clear, fast, interactive data analysis. This is what we need to know in order to build pipelines: The object on the left of the pipe operator (%&gt;%) is passed onto the first argument of the function on the right If we want to use the object on the left in other places than the first argument we can explicitly refer to it by using a dot (.) Here’s a pipeline which begins with raw data and ends with a plot after some data transformations steps in between. # the raw data... WorldPhones %&gt;% # ...is converted to a data frame... as.data.frame() %&gt;% # ...the rownames are added as the column `year`... # (note that I use the dot here to explicitly refer to the input data) mutate(year = as.integer(rownames(.))) %&gt;% # ...the data gets transformed from wide to long format... gather(key = cont, value = n, -year) %&gt;% # ...and finally plotted # (note that I can pipe the tidy data frame directly into ggplot) ggplot() + geom_line(aes(x = year, y = n, colour = cont)) The LHS of the pipe will always be the first argument of the RHS function, with a single exeption: When you use the dot variable on its own (non-nested) on the RHS. 3.3.1 Excercise: Pipes Rewrite the following expressions as pipes: sum(1:100) FALSE [1] 5050 #1:100 %&gt;% sum() sum(cumsum(1:100)) FALSE [1] 171700 #1:100 %&gt;% cumsum() %&gt;% sum() hist(colMeans(replicate(1000, runif(100)))) #replicate(1000, runif(100)) %&gt;% colMeans() %&gt;% hist() any(is.na(mtcars$cyl)) FALSE [1] FALSE #mtcars$cyl %&gt;% is.na() %&gt;% any() cor.test(~hp+mpg, data = mtcars) FALSE FALSE Pearson&#39;s product-moment correlation FALSE FALSE data: hp and mpg FALSE t = -6.7424, df = 30, p-value = 1.788e-07 FALSE alternative hypothesis: true correlation is not equal to 0 FALSE 95 percent confidence interval: FALSE -0.8852686 -0.5860994 FALSE sample estimates: FALSE cor FALSE -0.7761684 #mtcars %&gt;% cor.test(~ hp+mpg, data = .) cor.test(~hp+mpg, data = mtcars[1:10]) FALSE FALSE Pearson&#39;s product-moment correlation FALSE FALSE data: hp and mpg FALSE t = -6.7424, df = 30, p-value = 1.788e-07 FALSE alternative hypothesis: true correlation is not equal to 0 FALSE 95 percent confidence interval: FALSE -0.8852686 -0.5860994 FALSE sample estimates: FALSE cor FALSE -0.7761684 #mtcars %&gt;% {cor.test(~ hp+mpg, data = .[1:10])} cor(x = mtcars$mpg, y = mtcars$hp) FALSE [1] -0.7761684 #mtcars %&gt;% {cor(x = .$mpg, y = .$hp)} xtabs(~ gear + cyl, data = mtcars, subset = mtcars$gear &gt; 4) FALSE cyl FALSE gear 4 6 8 FALSE 5 2 1 2 #mtcars %&gt;% xtabs(~gear + cyl, data = ., subset = .$gear &gt; 4) 3.4 Tidy data Many programming tasks become easier once the data is in a tidy format. But what is tidy data? Our working definition: data needs to be a data frame and every variable of interest needs to be a separate column. Let’s explore what that means. head(WorldPhones) ## N.Amer Europe Asia S.Amer Oceania Africa Mid.Amer ## 1951 45939 21574 2876 1815 1646 89 555 ## 1956 60423 29990 4708 2568 2366 1411 733 ## 1957 64721 32510 5230 2695 2526 1546 773 ## 1958 68484 35218 6662 2845 2691 1663 836 ## 1959 71799 37598 6856 3000 2868 1769 911 ## 1960 76036 40341 8220 3145 3054 1905 1008 Here’s the number of telephone connections over time by continent. The data is not tidy because its not a data frame, it’s a matrix with row and column names. This gives us headaches if we want to use ggplot to plot the data. ggplot(WorldPhones) ## Error: `data` must be a data frame, or other object coercible by `fortify()`, not a numeric vector We can easily fix this problem by converting the matrix to a data frame. phones &lt;- as.data.frame(WorldPhones) Say we we want to plot the number of telephone connections over time by continent. This implies the following variables of interest: * the number of telephone connections `n` * the continent `cont` * the year `year` Problem is, none of these variables are explicitly given in our data frame. Of course the data is all there, just not in a format we can use (with ggplot). So the question is how to reshape the data into a form where all the variables of interest are separate columns in the data frame. To reshape we are going to use the libraries dplyr and tidyr. Both are loaded when you load library(tidyverse). The easiest variable to make explicit is the year. It is given as rownames of the data frame. We take the rownames, convert them from character to integer type, and add them as the variable year to the data frame. We use the tidyverse function mutate() to add a new variable to a data frame. phones &lt;- mutate(phones, year = as.integer(rownames(phones))) phones ## N.Amer Europe Asia S.Amer Oceania Africa Mid.Amer year ## 1 45939 21574 2876 1815 1646 89 555 1951 ## 2 60423 29990 4708 2568 2366 1411 733 1956 ## 3 64721 32510 5230 2695 2526 1546 773 1957 ## 4 68484 35218 6662 2845 2691 1663 836 1958 ## 5 71799 37598 6856 3000 2868 1769 911 1959 ## 6 76036 40341 8220 3145 3054 1905 1008 1960 ## 7 79831 43173 9053 3338 3224 2005 1076 1961 That leaves us with the variables “number of telephone connections” and “continent” to make explicit. They shall become separate columns in the data frame. With the help of gather() we transform from wide to long format. phones &lt;- gather(phones, key = cont, value = n, -year) phones ## year cont n ## 1 1951 N.Amer 45939 ## 2 1956 N.Amer 60423 ## 3 1957 N.Amer 64721 ## 4 1958 N.Amer 68484 ## 5 1959 N.Amer 71799 ## 6 1960 N.Amer 76036 ## 7 1961 N.Amer 79831 ## 8 1951 Europe 21574 ## 9 1956 Europe 29990 ## 10 1957 Europe 32510 ## 11 1958 Europe 35218 ## 12 1959 Europe 37598 ## 13 1960 Europe 40341 ## 14 1961 Europe 43173 ## 15 1951 Asia 2876 ## 16 1956 Asia 4708 ## 17 1957 Asia 5230 ## 18 1958 Asia 6662 ## 19 1959 Asia 6856 ## 20 1960 Asia 8220 ## 21 1961 Asia 9053 ## 22 1951 S.Amer 1815 ## 23 1956 S.Amer 2568 ## 24 1957 S.Amer 2695 ## 25 1958 S.Amer 2845 ## 26 1959 S.Amer 3000 ## 27 1960 S.Amer 3145 ## 28 1961 S.Amer 3338 ## 29 1951 Oceania 1646 ## 30 1956 Oceania 2366 ## 31 1957 Oceania 2526 ## 32 1958 Oceania 2691 ## 33 1959 Oceania 2868 ## 34 1960 Oceania 3054 ## 35 1961 Oceania 3224 ## 36 1951 Africa 89 ## 37 1956 Africa 1411 ## 38 1957 Africa 1546 ## 39 1958 Africa 1663 ## 40 1959 Africa 1769 ## 41 1960 Africa 1905 ## 42 1961 Africa 2005 ## 43 1951 Mid.Amer 555 ## 44 1956 Mid.Amer 733 ## 45 1957 Mid.Amer 773 ## 46 1958 Mid.Amer 836 ## 47 1959 Mid.Amer 911 ## 48 1960 Mid.Amer 1008 ## 49 1961 Mid.Amer 1076 We told the computer to look at all columns apart from year and transform them into the columns cont and n. cont holds the continent names for the variable n, the number of telephone connections. The continent names are taken from the original column names we gathered over. We now can plot our data easily. ggplot(phones) + geom_line(aes(x = year, y = n, colour = cont)) 3.4.1 Long versus wide format data Each table has a wide format and a long format representation. The information content is the same in both formats. It’s the layout that differs. Here’s a wide format table containing the explicit variables Female and Male. wide &lt;- data_frame(group = c(&quot;a&quot;, &quot;b&quot;), Female = 1:2, Male = 3:4) The same table in long format representation containing the explicit variables Sex and N. long &lt;- gather(wide, key = Sex, value = N, -group) long ## # A tibble: 4 x 3 ## group Sex N ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 a Female 1 ## 2 b Female 2 ## 3 a Male 3 ## 4 b Male 4 If we want to go back to a wide format we can achieve that by using the function spread(). spread(long, key = Sex, value = N) ## # A tibble: 2 x 3 ## group Female Male ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 a 1 3 ## 2 b 2 4 # hmd # Life tables by year, sex and country # source: Human Mortality Database load(&#39;data/hmd/hmd.RData&#39;) # common problems: no matching row was found hmd %&gt;% filter(period &gt; 2005, country == &#39;RUS&#39;, age == 0) %&gt;% spread(sex, ex) %&gt;% select(country, period, age, Female, Male) ## # A tibble: 27 x 5 ## country period age Female Male ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 RUS 2006 0 73.3 NA ## 2 RUS 2007 0 74.0 NA ## 3 RUS 2008 0 74.2 NA ## 4 RUS 2009 0 74.8 NA ## 5 RUS 2010 0 74.9 NA ## # ... with 22 more rows # solution hmd %&gt;% filter(period &gt; 2005, country == &#39;RUS&#39;, age == 0) %&gt;% select(-(nDx:Tx)) %&gt;% spread(sex, ex) %&gt;% select(country, period, age, Female, Male) ## # A tibble: 9 x 5 ## country period age Female Male ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 RUS 2006 0 73.3 60.4 ## 2 RUS 2007 0 74.0 61.4 ## 3 RUS 2008 0 74.2 61.9 ## 4 RUS 2009 0 74.8 62.8 ## 5 RUS 2010 0 74.9 63.1 ## # ... with 4 more rows 3.4.2 Making the implicit explicit # turn implicit NAs into explicit NAs eu_timeuse_tot %&gt;% skimr::n_missing() ## [1] 17 eu_timeuse_tot %&gt;% complete(activity_code, country_code, year) %&gt;% skimr::n_missing() ## [1] 2862 USArrests %&gt;% rownames_to_column(&#39;state&#39;) ## state Murder Assault UrbanPop Rape ## 1 Alabama 13.2 236 58 21.2 ## 2 Alaska 10.0 263 48 44.5 ## 3 Arizona 8.1 294 80 31.0 ## 4 Arkansas 8.8 190 50 19.5 ## 5 California 9.0 276 91 40.6 ## 6 Colorado 7.9 204 78 38.7 ## 7 Connecticut 3.3 110 77 11.1 ## 8 Delaware 5.9 238 72 15.8 ## 9 Florida 15.4 335 80 31.9 ## 10 Georgia 17.4 211 60 25.8 ## 11 Hawaii 5.3 46 83 20.2 ## 12 Idaho 2.6 120 54 14.2 ## 13 Illinois 10.4 249 83 24.0 ## 14 Indiana 7.2 113 65 21.0 ## 15 Iowa 2.2 56 57 11.3 ## 16 Kansas 6.0 115 66 18.0 ## 17 Kentucky 9.7 109 52 16.3 ## 18 Louisiana 15.4 249 66 22.2 ## 19 Maine 2.1 83 51 7.8 ## 20 Maryland 11.3 300 67 27.8 ## 21 Massachusetts 4.4 149 85 16.3 ## 22 Michigan 12.1 255 74 35.1 ## 23 Minnesota 2.7 72 66 14.9 ## 24 Mississippi 16.1 259 44 17.1 ## 25 Missouri 9.0 178 70 28.2 ## 26 Montana 6.0 109 53 16.4 ## 27 Nebraska 4.3 102 62 16.5 ## 28 Nevada 12.2 252 81 46.0 ## 29 New Hampshire 2.1 57 56 9.5 ## 30 New Jersey 7.4 159 89 18.8 ## 31 New Mexico 11.4 285 70 32.1 ## 32 New York 11.1 254 86 26.1 ## 33 North Carolina 13.0 337 45 16.1 ## 34 North Dakota 0.8 45 44 7.3 ## 35 Ohio 7.3 120 75 21.4 ## 36 Oklahoma 6.6 151 68 20.0 ## 37 Oregon 4.9 159 67 29.3 ## 38 Pennsylvania 6.3 106 72 14.9 ## 39 Rhode Island 3.4 174 87 8.3 ## 40 South Carolina 14.4 279 48 22.5 ## 41 South Dakota 3.8 86 45 12.8 ## 42 Tennessee 13.2 188 59 26.9 ## 43 Texas 12.7 201 80 25.5 ## 44 Utah 3.2 120 80 22.9 ## 45 Vermont 2.2 48 32 11.2 ## 46 Virginia 8.5 156 63 20.7 ## 47 Washington 4.0 145 73 26.2 ## 48 West Virginia 5.7 81 39 9.3 ## 49 Wisconsin 2.6 53 66 10.8 ## 50 Wyoming 6.8 161 60 15.6 3.4.3 Tidying data on police arrests Before we start plotting we need to ask ourselves: What do we need to do with our data in order to get the plot we want? Here are some examples. # we start with raw data... USArrests %&gt;% mutate( # ...and add the new variable `state` from the rownames... state = rownames(.), # ...we then reorder the levels of `state` according to the percentage of # people living in urban areas... state = reorder(state, UrbanPop)) %&gt;% # ...and make a dotplot of the percentage of urban population by state... ggplot() + geom_point(aes(x = UrbanPop, y = state)) # we start with raw data... USArrests %&gt;% mutate( # ...and add the new variable `state` from the rownames... state = rownames(.), # ...we then reorder the levels of `state` according to the combined # murder, assault and crime rates... state = reorder(state, Murder+Assault+Rape)) %&gt;% # ...we convert to long format, gathering &quot;Assault&quot;, &quot;Murder&quot; and &quot;Rape&quot; # into &quot;crime&quot;... gather(key = crime, value = rate, -state, -UrbanPop) %&gt;% # ...and make a dotplot of the crime-rate by crime and state ggplot() + geom_point(aes(x = rate, y = state, colour = crime)) 3.4.4 Tidying Anscombe’s quartet Can you figure out what happens here? Try running the code yourself line by line. anscombe %&gt;% mutate(id = seq_along(x1)) %&gt;% gather(... = -id) %&gt;% separate(key, sep = 1, into = c(&quot;axis&quot;, &quot;panel&quot;)) %&gt;% spread(key = axis, value = value) %&gt;% ggplot(aes(x = x, y = y)) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + geom_point() + facet_wrap(~panel) 3.4.5 Tidying data on test-retest reliability wide &lt;- read_csv(&quot;https://raw.githubusercontent.com/jschoeley/idem_viz/master/ggplot_practical/03-tidy_data/wide_data.csv&quot;) wide ## # A tibble: 48 x 20 ## name_rater1 area2d_camera1a area2d_camera1b area3d_camera1a ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 John 2.03 2.08 2.51 ## 2 Paul 0.300 0.420 0.510 ## 3 John 4.24 4.46 5.53 ## 4 John 2.87 3.08 4.03 ## 5 John 5.60 5.83 8.13 ## # ... with 43 more rows, and 16 more variables: area3d_camera1b &lt;dbl&gt;, ## # volume_camera1a &lt;dbl&gt;, volume_camera1b &lt;dbl&gt;, volume_gel1 &lt;dbl&gt;, ## # circum_camera1a &lt;dbl&gt;, … long &lt;- wide %&gt;% # add a unique identifier to each row (each patient) mutate(id = 1:nrow(.)) %&gt;% gather(key = type, value = value, -id, -name_rater1, -name_rater2) %&gt;% separate(col = type, into = c(&quot;measurement&quot;, &quot;method&quot;), sep = &quot;_&quot;) %&gt;% mutate(rater = ifelse(grepl(&#39;1&#39;, method), name_rater1, name_rater2)) %&gt;% separate(col = method, into = c(&quot;method&quot;, &quot;test&quot;), sep = &quot;\\\\d&quot;) %&gt;% mutate(test = ifelse(test == &quot;&quot;, &quot;a&quot;, test)) %&gt;% # beautification select(id, rater, test, measurement, method, value) %&gt;% arrange(id, measurement, rater, test) long ## # A tibble: 864 x 6 ## id rater test measurement method value ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 John a area2d camera 2.03 ## 2 1 John b area2d camera 2.08 ## 3 1 Paul a area2d camera 1.95 ## 4 1 Paul b area2d camera NA ## 5 1 John a area3d camera 2.51 ## # ... with 859 more rows long %&gt;% filter(method == &quot;camera&quot;) %&gt;% ggplot(aes(x = test, y = value)) + geom_line(aes(color= rater, group = id)) + facet_grid(rater~measurement) ## Warning: Removed 30 rows containing missing values (geom_path). Comparisions along the y-axis is easiest if the scales are aligned therefore it is easier to compare along the horizontal. long %&gt;% filter(method == &quot;camera&quot;) %&gt;% ggplot(aes(x = test, y = value)) + geom_line(aes(color= rater, group = id)) + facet_grid(measurement~rater) ## Warning: Removed 54 rows containing missing values (geom_path). Differences are seen most clearly when plotted directly. long %&gt;% filter(method == &quot;camera&quot;) %&gt;% spread(test, value = value) %&gt;% mutate(diff = a-b) %&gt;% ggplot() + geom_dotplot(aes(x = diff)) + facet_wrap(~rater) ## `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 39 rows containing non-finite values (stat_bindot). 3.4.6 Tidying the EU time-use-survey library(lubridate) library(eurostat) # Eurostat table &quot;tus_00selfstat&quot; eu_timeuse_complete &lt;- get_eurostat(&#39;tus_00selfstat&#39;, type = &#39;label&#39;, stringsAsFactors = FALSE) eu_timeuse &lt;- eu_timeuse_complete %&gt;% filter(sex == &#39;Total&#39;, wstatus == &#39;Population&#39;) %&gt;% spread(unit, values) %&gt;% mutate(year = year(time), prtcp_time_min = `Participation time (hh:mm)` %&gt;% str_pad(width = 4, side = &#39;left&#39;, pad = &#39;0&#39;) %&gt;% {str_c(str_sub(., 1, 2), &#39;:&#39;, str_sub(., 3, 4))} %&gt;% hm() %&gt;% time_length(unit = &#39;minutes&#39;), time_spent_min = `Time spent (hh:mm)` %&gt;% str_pad(width = 4, side = &#39;left&#39;, pad = &#39;0&#39;) %&gt;% {str_c(str_sub(., 1, 2), &#39;:&#39;, str_sub(., 3, 4))} %&gt;% hm() %&gt;% time_length(unit = &#39;minutes&#39;) ) %&gt;% select(activity = acl00, country = geo, year, prtcp_rate = `Participation rate (%)`, prtcp_time_min, time_spent_min) ## Warning in .parse_hms(..., order = &quot;HM&quot;, quiet = quiet): Some strings ## failed to parse, or all strings are NAs eu_timeuse ## # A tibble: 1,671 x 6 ## activity country year prtcp_rate prtcp_time_min time_spent_min ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Activities rela… Austria 2010 22.6 48 11 ## 2 Activities rela… Belgium 2000 1.4 88 1 ## 3 Activities rela… Belgium 2010 12.5 46 6 ## 4 Activities rela… Bulgar… 2000 7.1 39 3 ## 5 Activities rela… Estonia 2000 10.9 44 5 ## 6 Activities rela… Estonia 2010 6.9 45 3 ## 7 Activities rela… Finland 2000 7.2 23 2 ## 8 Activities rela… Finland 2010 8.3 27 2 ## 9 Activities rela… France 2000 1.6 102 2 ## 10 Activities rela… France 2010 7.1 51 4 ## # ... with 1,661 more rows 3.4.7 Tidying model output We “tidy” the output of the survfit function via the “broom” package. library(survival) surv &lt;- survfit( Surv(time = heart$start, time2 = heart$stop, event = heart$event) ~ heart$transplant ) surv ## Call: survfit(formula = Surv(time = heart$start, time2 = heart$stop, ## event = heart$event) ~ heart$transplant) ## ## records n.max n.start events median 0.95LCL 0.95UCL ## heart$transplant=0 103 103 0 30 149 69 NA ## heart$transplant=1 69 45 0 45 90 53 334 broom::tidy(surv) %&gt;% ggplot(aes(x = time, y = estimate)) + geom_step(aes(colour = strata)) Dobson (1990) Page 93: Randomized Controlled Trial. dat &lt;- data_frame( counts = c(18,17,15,20,10,20,25,13,12), outcome = gl(3,1,9), treatment = gl(3,3) ) dat_fit &lt;- glm(counts ~ outcome + treatment, family = poisson(), data = dat) broom::tidy(dat_fit) ## term estimate std.error statistic p.value ## 1 (Intercept) 3.044522e+00 0.1708987 1.781478e+01 5.426767e-71 ## 2 outcome2 -4.542553e-01 0.2021708 -2.246889e+00 2.464711e-02 ## 3 outcome3 -2.929871e-01 0.1927423 -1.520097e+00 1.284865e-01 ## 4 treatment2 1.337909e-15 0.2000000 6.689547e-15 1.000000e+00 ## 5 treatment3 1.421085e-15 0.2000000 7.105427e-15 1.000000e+00 broom::glance(dat_fit) ## null.deviance df.null logLik AIC BIC deviance df.residual ## 1 10.58145 8 -23.38066 56.76132 57.74744 5.129141 4 3.4.8 Excercise: Tidy data Download get_eurostat('t2020_10', time_format = 'raw') and write a pipe that calculates the difference between the current value and the target value over time for each country. 3.5 Joins # population change income &lt;- get_eurostat(&#39;tgs00026&#39;, stringsAsFactors = FALSE) %&gt;% select(geo, time, income = values) ## Table tgs00026 cached at /tmp/RtmpFntefL/eurostat/tgs00026_date_code_FF.rds # unemployment rate unemp &lt;- get_eurostat(&#39;tgs00010&#39;, stringsAsFactors = FALSE) %&gt;% filter(sex == &#39;T&#39;) %&gt;% select(geo, time, unemp = values) ## Table tgs00010 cached at /tmp/RtmpFntefL/eurostat/tgs00010_date_code_FF.rds # total fertility rate totfert &lt;- get_eurostat(&#39;tgs00100&#39;, stringsAsFactors = FALSE) %&gt;% select(geo, time, totfert = values) ## Table tgs00100 cached at /tmp/RtmpFntefL/eurostat/tgs00100_date_code_FF.rds # total life-expectancy lifeexp &lt;- get_eurostat(&#39;tgs00101&#39;, stringsAsFactors = FALSE) %&gt;% filter(sex == &#39;T&#39;) %&gt;% select(geo, time, lifeexp = values) ## Table tgs00101 cached at /tmp/RtmpFntefL/eurostat/tgs00101_date_code_FF.rds # population change popchange &lt;- get_eurostat(&#39;tgs00099&#39;, stringsAsFactors = FALSE) %&gt;% spread(indic_de, values) %&gt;% select(geo, time, netmigrate = CNMIGRATRT, growthrate = GROWRT, natgrowthrate = NATGROWRT) ## Table tgs00099 cached at /tmp/RtmpFntefL/eurostat/tgs00099_date_code_FF.rds # eu_regional_indicators &lt;- unemp %&gt;% full_join(totfert) %&gt;% full_join(lifeexp) %&gt;% full_join(popchange) %&gt;% full_join(income) %&gt;% filter(str_length(geo) == 4) %&gt;% mutate(country = str_sub(geo, end = 2)) %&gt;% arrange(geo, time) ## Joining, by = c(&quot;geo&quot;, &quot;time&quot;) ## Joining, by = c(&quot;geo&quot;, &quot;time&quot;) ## Joining, by = c(&quot;geo&quot;, &quot;time&quot;) ## Joining, by = c(&quot;geo&quot;, &quot;time&quot;) 3.5.1 Excercise: Joins Create a dataset to a single topic of your choice by joining eurostat tables. 3.6 Recoding 3.6.1 Excercise: Recoding Recode the activity variable in dataset eu_timeuse into less than 10 meaningful categories of your own choice (make sure to filter out the “Total” values first). Visualize. 3.7 Tidy iteration 3.7.1 Group-wise operations 3.7.1.1 Grouped mutate() If we want to transform some columns in the data frame on a group-by-group basis we can use the group_by() together with mutate(). Biologists sometimes express age not in years but in shares of total life-expectancy, i.e. the age of quarter life-expectancy, the age of half life-expectancy… Let’s add this relative age to each life-table in the data. We need to group our data into sub-groups defined by the values of country, sex and year for each sub-group add a new column “relative age” to the life-table calculated as age over total life-expectancy Re-combine the results of 2 into a data frame with columns identifying the sub-groups # hmd # Life tables by year, sex and country # source: Human Mortality Database load(&#39;data/hmd/hmd.RData&#39;) hmd %&gt;% group_by(country, sex, period) %&gt;% mutate(relAge = age / ex[1]) %&gt;% select(-(nx:ex)) ## # A tibble: 1,304,694 x 6 ## # Groups: country, sex, period [11,754] ## country country_name sex period age relAge ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 AUS Australia Female 1921 0 0 ## 2 AUS Australia Female 1921 1 0.0158 ## 3 AUS Australia Female 1921 2 0.0317 ## 4 AUS Australia Female 1921 3 0.0475 ## 5 AUS Australia Female 1921 4 0.0633 ## # ... with 1.305e+06 more rows Let’s plot the life-table survivor function over relative age by sex for Sweden across periods. hmd %&gt;% group_by(country, sex, period) %&gt;% mutate(relAge = age / ex[1]) %&gt;% ungroup() %&gt;% filter(country == &#39;SWE&#39;) %&gt;% ggplot() + geom_line(aes(x = relAge, y = lx, group = period, color = period)) + facet_wrap(~sex) 3.7.1.2 Grouped filter() 3.7.1.3 Grouped slice() slice() selects rows by index. Using slice() in a grouped fashion we can return the first and last row for each group – this comes in handy as a quick check for data structure and coverage. # euro_regio # European regional population statistics load(&#39;data/euro_regio/euro_regio.Rdata&#39;) euro_regio %&gt;% # for each country... group_by(country_name) %&gt;% # ...return the first and last row slice(c(1, n())) ## # A tibble: 72 x 21 ## # Groups: country_name [36] ## country_code country_name nuts2_code nuts2_name year pop popdens ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AL Albania AL01 Veri 2005 NA NA ## 2 AL Albania ALXX ALXX Not regio… 2017 NA NA ## 3 AT Austria AT11 Burgenland (AT) 2005 NA 75.7 ## 4 AT Austria ATZZ ATZZ Extra-Reg… 2017 NA NA ## 5 BE Belgium BE10 Région de Brux… 2005 NA 6290. ## # ... with 67 more rows, and 14 more variables: births &lt;dbl&gt;, ## # deaths &lt;dbl&gt;, natgrowthrate &lt;dbl&gt;, growthrate &lt;dbl&gt;, netmigrate &lt;dbl&gt;, ## # … We can use grouped slice() to have a closer look at outliers within groups. This replicates the Oeppen-Vaupel line for European regions. euro_regio %&gt;% # for each year group_by(year) %&gt;% #...select the row (region) with the highest life-expectancy slice(which.max(lifeexp)) %&gt;% # ...and plot the results ggplot() + geom_line(aes(x = year, y = lifeexp), color = &#39;grey&#39;) + geom_label(aes(x = year, y = lifeexp, label = nuts2_name, color = nuts2_name), show.legend = FALSE, size = 3) 3.7.2 Grouped summarise() Say we have a collection of life-tables by country, sex, and year and we want to calculate the coefficient of variation for the life-table distribution of deaths. In other words we want to group our data into subgroups defined by the values of country, sex and year (so a single sub-group may be Danish females in 2010) extract total life-expectancy from each sub-group life-table calculate the coefficient of variation for each sub-group Re-combine the results of 2 and 3 into a data frame with columns identifying the sub-groups All of the above is achieved by the data pipeline below. hmd %&gt;% group_by(country, sex, period) %&gt;% summarise( e0 = first(ex), cv = sqrt(sum(ndx/100000*(age+nax-e0)^2)) / e0 ) ## # A tibble: 11,754 x 5 ## # Groups: country, sex [?] ## country sex period e0 cv ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUS Female 1921 63.2 0.409 ## 2 AUS Female 1922 65.1 0.370 ## 3 AUS Female 1923 63.7 0.388 ## 4 AUS Female 1924 64.5 0.383 ## 5 AUS Female 1925 65.4 0.370 ## # ... with 1.175e+04 more rows We use the group_by() function to group our data into sub-groups, then we use the summarise() command to calculate the “summary statistics” for each sub-group. The ungroup() function in the end is optional but its good practive to ungroup after you’re done with the group-wise operations. Let’s plot the results (for a subset of all countries): hmd %&gt;% filter(sex != &#39;Total&#39;) %&gt;% group_by(country, sex, period) %&gt;% summarise( e0 = first(ex), cv = sqrt(sum(ndx/100000*(age+nax-e0)^2)) / e0 ) %&gt;% ungroup() %&gt;% filter(country %in% c(&#39;SWE&#39;, &#39;RUS&#39;, &#39;ITA&#39;, &#39;DNK&#39;, &#39;USA&#39;, &#39;ESP&#39;)) %&gt;% ggplot() + geom_path(aes(x = e0, y = cv, color = sex)) + facet_wrap(~country, scales = &#39;free&#39;) 3.7.2.1 Grouped do() 3.7.2.2 Fitting and summarising many models 3.7.2.3 Excercise: Group-wise operations Calculate five year abridged mortality rates for the whole hmd_counts data. 3.7.3 Column-wise operations 3.7.3.1 *_at() # apply function &quot;toupper()&quot; to the columns country, sex mutate_at(hmd_counts, vars(country, sex), toupper) ## # A tibble: 1,304,694 x 7 ## country sex period age nx nDx nEx ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUS FEMALE 1921 0 1 3842. 64052. ## 2 AUS FEMALE 1921 1 1 719. 59619. ## 3 AUS FEMALE 1921 2 1 330. 57126. ## 4 AUS FEMALE 1921 3 1 166. 57484. ## 5 AUS FEMALE 1921 4 1 190. 58407. ## # ... with 1.305e+06 more rows # this returns the same as above mutate(hmd_counts, country = toupper(country), sex = toupper(sex)) ## # A tibble: 1,304,694 x 7 ## country sex period age nx nDx nEx ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUS FEMALE 1921 0 1 3842. 64052. ## 2 AUS FEMALE 1921 1 1 719. 59619. ## 3 AUS FEMALE 1921 2 1 330. 57126. ## 4 AUS FEMALE 1921 3 1 166. 57484. ## 5 AUS FEMALE 1921 4 1 190. 58407. ## # ... with 1.305e+06 more rows 3.7.3.2 *_if() # convert any character variable to a factor mutate_if(hmd_counts, is.character, as.factor) ## # A tibble: 1,304,694 x 7 ## country sex period age nx nDx nEx ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUS Female 1921 0 1 3842. 64052. ## 2 AUS Female 1921 1 1 719. 59619. ## 3 AUS Female 1921 2 1 330. 57126. ## 4 AUS Female 1921 3 1 166. 57484. ## 5 AUS Female 1921 4 1 190. 58407. ## # ... with 1.305e+06 more rows # this returns the same as above mutate(hmd_counts, country = as.factor(country), sex = as.factor(sex)) ## # A tibble: 1,304,694 x 7 ## country sex period age nx nDx nEx ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUS Female 1921 0 1 3842. 64052. ## 2 AUS Female 1921 1 1 719. 59619. ## 3 AUS Female 1921 2 1 330. 57126. ## 4 AUS Female 1921 3 1 166. 57484. ## 5 AUS Female 1921 4 1 190. 58407. ## # ... with 1.305e+06 more rows 3.7.3.3 *_all() "],
["visualization.html", "Chapter 4 Visualization 4.1 The “tidy” approach to data visualization 4.2 The Grammar of graphics 4.3 Order 4.4 Facets 4.5 Chart type vocabulary 4.6 Polish your plot for publication 4.7 Maps 4.8 Networks", " Chapter 4 Visualization 4.1 The “tidy” approach to data visualization Data visualization in the tidyverse revolves around three concepts: Tidy Data Data is stored is a data frame with cases as rows and variables as columns. Mappings Variables are mapped to visual attributes, called aesthetics. Layers Plots are build layer by layer. There are different types of layers, each changing a different aspect of a plot, i.e. coordinate system, scales, statistical transformations or visual marks. Part of the tidyverse is a package called ggplot2 which is what we are going to use to produce plots. ggplot2 is an implementation of the Grammar of Graphics, a domain specific language to specify visualizations. 4.2 The Grammar of graphics Data, Statistics, Aestetics, Scales, Geometry, Coordinates. Data Observations of one or more variables. Statistics Transformations of the data prior to plotting. Algebraic transformations (log, exp, sqrt, identical…) Aggregating statistical transformations (mean, median, mode, bin, linear regression…) Non-aggregating statistical transformations (sort, rank, cut…) Aesthetics The visual representation of a variable. Position. x, y, xmin, xmax, ymin, ymax, xend, yend Colour. colour, fill, alpha Size. size Shape, Pattern. shape, linetype Group. group Angle, Slope, Intercept, Texture, … Scales The way a variable is mapped to a visual representation. Discrete, Continous. e.g. scale_x_discrete, scale_colour_continuous Concerning Position, Colour, Size, Shape… e.g. scale_y_continuous, scale_size, scale_shape() Breakpoints, Labels Transformations (log, sqrt, reverse) Geometry General “shape” or “type” of the graphic Scatterplots use geom_point, Timelines use geom_line, Area charts use geom_area, Heatmaps use geom_tile, Bar charts use geom_bar, there are many more… Coordinates The coordinate system of the plot area. Cartesian coordinates Polar coordinates 4.2.1 Aesthetics, geometries, and layers Interactive plots displayed in a web-browser have long arrived in the mainstream with Gapminder World being a true classic of the genre. Gapminder World Today we shall recreate the above chart and in doing so learn the basics of ggplot. Key concepts we will tackle are aesthetics, layers, scales, and facets. Each ggplot starts with data. Data must be a data frame! Today we will use data which comes in form of an R package: The gapminder data. library(tidyverse) library(gapminder) is.data.frame(gapminder) ## [1] TRUE head(gapminder) ## # A tibble: 6 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## # ... with 1 more row First step in plotting with ggplot – provide ggplot with a data frame: ggplot(data = gapminder) ggplot knows about our data but nothing happens yet. We need to add a layer. We add elements to a plot by adding them with a +. ggplot(data = gapminder) + geom_line(aes(x = year, y = lifeExp)) aes stands for aesthetics: Mappings between variables in our data and visual properties. Each column in our data frame is a variable. Visual properties are manifold and can be x, y, colour, size, shape, alpha, fill, radius, linetype, group… We use the aes() function to map x-position to the variable Time and y-position to the variable weight. Every time you map a variable to a visual property you do it inside aes() The plot looks strange. A single line is drawn across all data points. We want separate lines – one time series per country… ggplot(data = gapminder) + geom_line(aes(x = year, y = lifeExp, group = country)) Note that we don’t write x = gapminder$year or y = &quot;lifeExp&quot;. We simply spell out the name of the variable we wish to work with. ggplot is aware of the dataset we work with – it is attached. Quoting the variable names would actually produce unexpected results: ggplot(data = gapminder) + geom_line(aes(x = &quot;year&quot;, y = &quot;lifeExp&quot;, group = &quot;country&quot;)) What happened? ggplot interpreted the quoted strings as raw data instead of variable names of our data frame. It then tries to plot it… Always use unquoted column names to address the variables in your data. Let’s colour all of the lines blue. ggplot(data = gapminder) + geom_line(aes(x = year, y = lifeExp, group = country), colour = &quot;blue&quot;) We wrote colour = &quot;blue&quot; outside of the aes() function as we set the visual property to a fixed value instead of mapping a visual property to a variable in the data frame. For comparison, let’s move the colour specification into the aes() function: ggplot(data = gapminder) + geom_line(aes(x = year, y = lifeExp, group = country, colour = &quot;blue&quot;)) Classic ggplot moment here… “blue” gets interpreted as raw data as we have written it inside of the aes() function. ggplot thinks all of our rows belong to group “blue”, mapped to the visual property colour. ggplot assigns a default colour scale of which the first colour is a light red. Here’s the same behaviour, but this time it makes sense as we map colour to an actual variable in our data set. ggplot(data = gapminder) + geom_line(aes(x = year, y = lifeExp, group = country, colour = continent)) Lesson to be learned: The difference between mapping and setting a visual property. You map visual properties to variables inside aes(), you set visual properties to a fixed value outside of aes(). We can add more than a single layer to a plot. ggplot 2.0.0 comes with 27 geometries (geom). Some of them are super straightforward and just draw points or lines or rectangles. Some draw complex shapes after transforming your data in various ways. Think of geometries as flexible templates for different plot types. Combining different geometries is a common workflow in ggplot. E.g. adding geom_point to geom_line gives lines with points on them: # filter data to 4 countries only gapminder_sub &lt;- filter(gapminder, country %in% c(&quot;China&quot;, &quot;Switzerland&quot;, &quot;United States&quot;, &quot;Somalia&quot;)) ggplot(data = gapminder_sub) + geom_line(aes(x = year, y = lifeExp, color = country)) + geom_point(aes(x = year, y = lifeExp, color = country)) Note that we did not need to specify the group argument in the last ggplot call. The have mapped colour to country and therefore implicitly specified the grouping structure of our data. We use group only if ggplot fails to correctly guess the grouping. If we use identical mappings in our layers we can move them into the ggplot() function. Everything inside the ggplot() function is passed down to all other plot elements. ggplot(data = gapminder_sub, aes(x = year, y = lifeExp, color = country)) + geom_line() + geom_point() We can still add arguments to the individual layers. ggplot(data = gapminder_sub, aes(x = year, y = lifeExp, color = country)) + geom_line(aes(linetype = country)) + geom_point(aes(shape = country)) We also have the power to override commands from above: ggplot(data = gapminder_sub, aes(x = year, y = lifeExp, color = country)) + geom_line(aes(linetype = country), colour = &quot;black&quot;) + geom_point(aes(shape = country), colour = &quot;black&quot;) 4.2.2 Scales We already know that aesthetics are mappings from data dimensions to visual properties. They tell ggplot what goes where. What are the aesthetics in Gapminder World? Data dimension Visual property Scale GDP per capita position on x-axis (x) scale_x_* Life expectancy position on y-axis (y) scale_y_* Population size size of plotting symbols (size) scale_size_* Geographical Region colour of plotting symbols (colour) scale_colour_* Each aesthetic has its own scale The four aesthetics in Gapminder World are connected to four different scales. The scales are named after the corresponding aesthetic. The naming scheme is scale_&lt;name of aesthetic&gt;_&lt;continuous|discrete|specialized&gt;. Aesthetics specify the what, scales specify the how Which colour to use for which level in the data? Where to put the labels on the axis? Which labels to put? The size of the largest plotting symbol, the name of the legends, log-transformation of the y-axis, the range of the axis… These are all examples of scale specifications – specifications on how to map a data dimension to a visual attribute. Off to work! library(gapminder) head(gapminder) ## # A tibble: 6 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## # ... with 1 more row The data already looks tidy. All we have to do is to subset to a single year. Let’s see what ggplot produces if we simply specify the aesthetics to an appropriate geometry. gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)) + geom_point() A solid foundation. But to close in on the Gapminder World chart we need to customize our scales. When changing scale attributes we have to make sure to make the changes on the appropriate scale. Just ask yourself: What aesthetic does the scale correspond to? scale_&lt;name of aesthetic&gt;_* Am I dealing with a discrete or continuous variable? scale_*_&lt;continuous|discrete&gt; 4.2.2.1 Naming scales Once you know which scales to use, names are trivial to change. gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)) + geom_point() + scale_x_continuous(name = &quot;Income per person (GDP/capita, PPP$ inflation-adjusted)&quot;) + scale_y_continuous(name = &quot;Life expectancy (years)&quot;) + scale_color_discrete(name = &quot;Continent&quot;) + scale_size_continuous(name = &quot;Population, total&quot;) You can also use mathematical annotation in your scale names. For further information consult ?plotmath. gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)) + geom_point() + scale_x_continuous(name = expression(over(GDP, capita))) + scale_y_continuous(name = expression(e[0])) + scale_color_discrete(name = &quot;Continent&quot;) + scale_size_continuous(name = &quot;Population, total&quot;) 4.2.2.2 Scale transformations Next, we deal with scale transformations. In Gapminder World the x-axis is log-scaled meaning that the log of the x-axis data is taken before plotting. However, the labels remain on the linear scale. In that regard transforming scales is different from directly transforming the underlying data. gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)) + geom_point() + scale_x_continuous(name = &quot;Income per person (GDP/capita, PPP$ inflation-adjusted)&quot;, trans = &quot;log10&quot;) + scale_y_continuous(name = &quot;Life expectancy (years)&quot;) + scale_color_discrete(name = &quot;Continent&quot;) + scale_size_continuous(name = &quot;Population, total&quot;) There are many different scale transformations built into ggplot. From the documentation: Built-in transformations include “asn”, “atanh”, “boxcox”, “exp”, “identity”, “log”, “log10”, “log1p”, “log2”, “logit”, “probability”, “probit”, “reciprocal”, “reverse” and “sqrt”. gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)) + geom_point() + scale_x_continuous(name = &quot;Income per person (GDP/capita, PPP$ inflation-adjusted)&quot;, trans = &quot;reverse&quot;) + scale_y_continuous(name = &quot;Life expectancy (years)&quot;) + scale_color_discrete(name = &quot;Continent&quot;) + scale_size_continuous(name = &quot;Population, total&quot;) Note that the concept of scale transformations is not limited to position scales. gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)) + geom_point() + scale_x_continuous(name = &quot;Income per person (GDP/capita, PPP$ inflation-adjusted)&quot;, trans = &quot;log10&quot;) + scale_y_continuous(name = &quot;Life expectancy (years)&quot;) + scale_color_discrete(name = &quot;Continent&quot;) + scale_size_continuous(name = &quot;Population, total&quot;, trans = &quot;log10&quot;) 4.2.2.3 Scale breaks and labels Next, we manually specify the axis breaks and labels to be the same as in Gapminder World. Axis breaks are the positions where tick-marks and grid-lines are drawn. Labels specify what text to put at the breaks. Breaks and labels have to be vectors of equal length. gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)) + geom_point() + scale_x_continuous(name = &quot;Income per person (GDP/capita, PPP$ inflation-adjusted)&quot;, trans = &quot;log10&quot;, breaks = c(200, 300, 400, 500, 600, 700, 800, 900, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000), labels = c(&quot;200&quot;, &quot;&quot;, &quot;400&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;1000&quot;, &quot;2000&quot;, &quot;&quot;, &quot;4000&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;10000&quot;, &quot;20000&quot;, &quot;&quot;, &quot;40000&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;)) + scale_y_continuous(name = &quot;Life expectancy (years)&quot;, breaks = c(25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85)) + scale_color_discrete(name = &quot;Continent&quot;) + scale_size_continuous(name = &quot;Population, total&quot;) OK, that was effective but clumsy. Luckily ggplot does not care how we generate the vector of breaks. We can use any R function as long as it outputs a vector. Even better, instead of manually spelling out the labels for each break we can write a short function that takes the breaks as input and formats them. Much nicer code – same result. gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)) + geom_point() + scale_x_continuous(name = &quot;Income per person (GDP/capita, PPP$ inflation-adjusted)&quot;, trans = &quot;log10&quot;, breaks = apply(expand.grid(1:9, 10^(2:4)), 1, FUN = prod)[-1], labels = function(x) ifelse(grepl(&#39;^[124]&#39;, x), x, &#39;&#39;)) + scale_y_continuous(name = &quot;Life expectancy (years)&quot;, breaks = seq(25, 85, 5)) + scale_color_discrete(name = &quot;Continent&quot;) + scale_size_continuous(name = &quot;Population, total&quot;) The concept of breaks and labels does not only apply to continuous axis. All scales have breaks and labels. E.g. on a colour scale the breaks are the colour keys, the labels are – well – the labels. We reorder the items on our discrete scale by specifying the breaks in the required order. We also use an R function to capitalize the labels. gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)) + geom_point() + scale_x_continuous(name = &quot;Income per person (GDP/capita, PPP$ inflation-adjusted)&quot;, trans = &quot;log10&quot;, breaks = apply(expand.grid(1:9, 10^(2:4)), 1, FUN = prod)[-1], labels = function(x) ifelse(grepl(&quot;^[124]&quot;, x), x, &quot;&quot;)) + scale_y_continuous(name = &quot;Life expectancy (years)&quot;, breaks = seq(25, 85, 5)) + scale_color_discrete(name = &quot;Continent&quot;, breaks = c(&quot;Asia&quot;, &quot;Africa&quot;, &quot;Americas&quot;, &quot;Europe&quot;, &quot;Oceania&quot;), labels = toupper) + scale_size_continuous(name = &quot;Population, total&quot;) Finally, let’s choose some sensible breaks and labels for the size scale. gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)) + geom_point() + scale_x_continuous(name = &quot;Income per person (GDP/capita, PPP$ inflation-adjusted)&quot;, trans = &quot;log10&quot;, breaks = apply(expand.grid(1:9, 10^(2:4)), 1, FUN = prod)[-1], labels = function(x) ifelse(grepl(&quot;^[124]&quot;, x), x, &quot;&quot;)) + scale_y_continuous(name = &quot;Life expectancy (years)&quot;, breaks = seq(25, 85, 5)) + scale_color_discrete(name = &quot;Continent&quot;, breaks = c(&quot;Asia&quot;, &quot;Africa&quot;, &quot;Americas&quot;, &quot;Europe&quot;, &quot;Oceania&quot;), labels = toupper) + scale_size_continuous(name = &quot;Population, total&quot;, breaks = c(1E6, 10E6, 100E6, 1E9), labels = function(x) format(x, big.mark = &quot;,&quot;, scientific = FALSE)) 4.2.2.4 Scale limits We match the maximum and minimum value of our xy-scales with those of the Gapminder World chart by specifying the limits of the scales. gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, size = pop, colour = continent)) + geom_point() + scale_x_continuous(name = &quot;Income per person (GDP/capita, PPP$ inflation-adjusted)&quot;, trans = &quot;log10&quot;, breaks = apply(expand.grid(1:9, 10^(2:4)), 1, FUN = prod)[-1], labels = function(x) ifelse(grepl(&quot;^[124]&quot;, x), x, &quot;&quot;), limits = c(200, 90000)) + scale_y_continuous(name = &quot;Life expectancy (years)&quot;, breaks = seq(25, 85, 5), limits = c(25, 85)) + scale_color_discrete(name = &quot;Continent&quot;, breaks = c(&quot;Asia&quot;, &quot;Africa&quot;, &quot;Americas&quot;, &quot;Europe&quot;, &quot;Oceania&quot;), labels = toupper) + scale_size_continuous(name = &quot;Population, total&quot;, breaks = c(1E6, 10E6, 100E6, 1E9), labels = function(x) format(x, big.mark = &quot;,&quot;, scientific = FALSE)) 4.2.2.5 Limiting versus zooming Note that values outside of the limits will be discarded. This is of importance if you want to zoom into a plot. Here we “zoom” by changing the limits of the scales… gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point(size = 20) + scale_x_continuous(limits = c(5000, 20000)) + scale_y_continuous(limits = c(70, 80)) ## Warning: Removed 104 rows containing missing values (geom_point). …and here we zoom by changing the limits of the coordinate system gapminder %&gt;% filter(year == 2007) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point(size = 20) + coord_cartesian(xlim = c(5000, 20000), ylim = c(70, 80)) 4.2.3 Excercise: The grammar of graphics 4.3 Order 4.3.1 Factor levels control the order of discrete scales It is easy to order items on a numerical scale. One just puts them on the number line. Usually low on the left and hight to the right. But what about discrete items? ggplot orders them according to the order of their factor levels. An example: # test data foo &lt;- data.frame(id = 1:4, sex = c(&quot;Female&quot;, &quot;Female&quot;, &quot;Male&quot;, &quot;Male&quot;)) foo ## id sex ## 1 1 Female ## 2 2 Female ## 3 3 Male ## 4 4 Male data.frame, just like ggplot, automatically converts a character vector to a factor using as.factor. The levels order of that factor follows the sequence of occurrence in the data. levels(foo$sex) ## [1] &quot;Female&quot; &quot;Male&quot; ggplot constructs discrete scales in the order of the levels of the underlying factor variable. Here, Females first, males after. ggplot(foo) + geom_point(aes(x = sex, y = id, color = sex)) If we reverse the level order of the sex variable we change the way ggplot orders the discrete items. foo$sex ## [1] Female Female Male Male ## Levels: Female Male foo$sex &lt;- factor(foo$sex, levels = c(&quot;Male&quot;, &quot;Female&quot;)) foo$sex ## [1] Female Female Male Male ## Levels: Male Female Now we have males first and females last. ggplot(foo) + geom_point(aes(x = sex, y = id, color = sex)) ggplot(foo) + geom_point(aes(x = sex, y = id, color = sex)) + facet_wrap(~sex) NEVER OVERRIDE THE LEVELS DIRECTLY WHEN JUST MEANING TO CHANGE THE ORDER! You’ll screw up your data. In our case we just changed the sex of the participants. foo$sex ## [1] Female Female Male Male ## Levels: Male Female levels(foo$sex) &lt;- c(&quot;Female&quot;, &quot;Male&quot;) foo$sex ## [1] Male Male Female Female ## Levels: Female Male 4.3.2 Layers are plotted on top of each other library(gapminder) gapminder %&gt;% filter(year %in% c(1952, 2007)) %&gt;% group_by(year) %&gt;% mutate(e0rank = n() - rank(lifeExp)) %&gt;% filter(e0rank &lt;= 30) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_text(aes(label = country, color = continent, size = pop)) + scale_x_log10() + geom_smooth(method = &quot;lm&quot;, size = 2) + facet_wrap(~year) gapminder %&gt;% filter(year %in% c(1952, 2007)) %&gt;% group_by(year) %&gt;% mutate(e0rank = n() - rank(lifeExp)) %&gt;% filter(e0rank &lt;= 30) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_smooth(method = &quot;lm&quot;, size = 2) + geom_text(aes(label = country, color = continent, size = pop)) + scale_x_log10() + facet_wrap(~year) 4.3.3 Sometimes the row-order of the data matters Sometimes the row-order of a dataframe has implications for visualization. This is true for ggplots geom_point() which draws points in the order of occurence in a dataframe. In the example below we scale the points by the population size of a country. Arranging the dataframe by decreasing population size makes sure that the smaller points are drawn last, i.e. on top of the larger points. gapminder %&gt;% arrange(pop) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, size = pop)) + geom_point(fill = &#39;black&#39;, color = &#39;white&#39;, shape = 21) + scale_x_log10() + scale_size_area() + facet_wrap(~year) gapminder %&gt;% arrange(desc(pop)) %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, size = pop)) + geom_point(fill = &#39;black&#39;, color = &#39;white&#39;, shape = 21) + scale_x_log10() + scale_size_area() + facet_wrap(~year) gapminder %&gt;% filter(country == &#39;Afghanistan&#39;) %&gt;% arrange(pop) %&gt;% ggplot(aes(x = lifeExp, y = gdpPercap)) + geom_path() + geom_label(aes(label = year)) gapminder %&gt;% filter(country == &#39;Afghanistan&#39;) %&gt;% arrange(year) %&gt;% ggplot(aes(x = lifeExp, y = gdpPercap)) + geom_path() + geom_label(aes(label = year)) 4.4 Facets 4.4.1 Comparing sub-groups to totals https://drsimonj.svbtle.com/plotting-background-data-for-groups-with-ggplot2 4.5 Chart type vocabulary 4.5.1 Visualizing distributions Distribiutions are at the heart of statistics as they inform us about about the “typical” in a population, the degree of deviation from the typical, the “extreme”, and everything in between. Visualizing the distribution of a collection of values allows us to appreciate the diversity in our sample, understand the variability around a mean, choose the correct model specification, decide if the data is iid. 4.5.1.1 Continuous # European regional population statistics load(&#39;data/euro_regio/euro_regio_eu.Rdata&#39;) The most popular technique to visualize a distribution is the histogram. Here we use it to show how life-expectancy is distributed across the regions of the European Union in 2015. euro_regio_eu %&gt;% filter(year == 2015) %&gt;% ggplot() + geom_histogram(aes(x = lifeexp)) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 18 rows containing non-finite values (stat_bin). A histogram is a visual representation of binned data: a variable gets cut into intervals, the cases tabulated over those intervals and the resulting counts plotted as a shaded region. This whole binning operation is performed by geom_histogram(). We can change the details of that data transformation, e.g. using single year bins. euro_regio_eu %&gt;% filter(year == 2015) %&gt;% ggplot() + geom_histogram(aes(x = lifeexp), binwidth = 1) ## Warning: Removed 18 rows containing non-finite values (stat_bin). By default ggplot picks a binwidth of 1/30th the range of the data, yet the optimal binwidth for a histogram depends on the range of your data, the number of observations, and the desired trade-off between detail and smoothing. The fewer the observations, the bigger the bins need to be in order to create a usefull histogram. Say we want to show the distribution of life-expectancy among the 29 French NUTS-2 regions in 2015. Below you see 3 variations of doing that, using a binwidth of A) 1 month, B) half a year, and C) a year. cowplot::plot_grid( euro_regio_eu %&gt;% filter(year == 2015, country_code == &#39;FR&#39;) %&gt;% ggplot() + geom_histogram(aes(x = lifeexp), binwidth = 1/12), euro_regio_eu %&gt;% filter(year == 2015, country_code == &#39;FR&#39;) %&gt;% ggplot() + geom_histogram(aes(x = lifeexp), binwidth = 1), euro_regio_eu %&gt;% filter(year == 2015, country_code == &#39;FR&#39;) %&gt;% ggplot() + geom_histogram(aes(x = lifeexp), binwidth = 5), labels = &#39;AUTO&#39;, ncol = 3 ) ## Warning: Removed 4 rows containing non-finite values (stat_bin). ## Warning: Removed 4 rows containing non-finite values (stat_bin). ## Warning: Removed 4 rows containing non-finite values (stat_bin). Consider using a dot-histogram when ovservations are few (&lt;100). A dot-histogram1 draws a single point for each observation, located at the center of the respective bin. This makes for a very intuitive visualization as the individual observations are still visible despite being aggregated into bins. Sadly the implementation of dot-histograms in ggplot is a bit lacking at the time of writing which necessitates to use our data wrangling skills to get a nice result. # A trick I&#39;ve learned from John Tukey&#39;s EDA: Label individual cases in # dot-histograms. Aggregate and individual view at once! # Here&#39;s how you do it in R: (link) the_data &lt;- euro_regio_eu %&gt;% filter(year == 2015, country_code == &#39;ES&#39;) %&gt;% select(id = nuts2_code, value = unemp) # Label by id ------------------------------------------------------------- the_data %&gt;% mutate(bin = cut(value, seq(0, 30, 5))) %&gt;% na.omit() %&gt;% group_by(bin) %&gt;% arrange(value) %&gt;% mutate(count = 1:n()) %&gt;% ggplot(aes(x = bin, y = count)) + geom_point(aes(color = id), size = 11, color = &#39;grey80&#39;) + geom_text(aes(label = id), size = 3.4) + scale_x_discrete(drop = FALSE) + theme_minimal() # Label by value ---------------------------------------------------------- the_data %&gt;% mutate(bin = cut(value, seq(0, 30, 5))) %&gt;% na.omit() %&gt;% group_by(bin) %&gt;% arrange(value) %&gt;% mutate(count = 1:n()) %&gt;% ggplot(aes(x = bin, y = count)) + geom_point(aes(color = id), size = 11, color = &#39;grey80&#39;) + geom_text(aes(label = value), size = 3.4) + scale_x_discrete(drop = FALSE) + theme_minimal() # Works with grouping as well --------------------------------------------- the_data2 &lt;- euro_regio_eu %&gt;% filter(country_code == &#39;ES&#39;, year %in% c(2007, 2012, 2017)) %&gt;% select(group = year, id = nuts2_code, value = unemp) the_data2 %&gt;% mutate(bin = cut(value, seq(0, 40, 5))) %&gt;% na.omit() %&gt;% group_by(group, bin) %&gt;% arrange(value) %&gt;% mutate(count = 1:n()) %&gt;% ggplot(aes(x = bin, y = count)) + geom_point(aes(color = id), size = 6, color = &#39;grey80&#39;) + geom_text(aes(label = id), size = 2) + scale_x_discrete(drop = FALSE) + theme_minimal() + coord_flip() + facet_wrap(~group) Whenever a geom uses a statistical transformation, such as the binning in geom_histogram(), a number of new variables are internally computed by ggplot prior to plotting. In case of geom_histogram() these new variables are count: number of points in bin density: density of points in bin ncount: count, scaled to a maximum of 1 ndensity: density, scaled to a maximum of 12 Via the stat() function we can use any of the computed variables in our plot. This makes it possible to draw histograms with density on the y axis instead of the default count. euro_regio_eu %&gt;% filter(year == 2015) %&gt;% ggplot() + geom_histogram(aes(x = lifeexp, y = stat(density)), binwidth = 1) ## Warning: Removed 18 rows containing non-finite values (stat_bin). An alternative to the histogram is the density plot. euro_regio_eu %&gt;% filter(year == 2015) %&gt;% ggplot() + geom_density(aes(x = lifeexp)) ## Warning: Removed 18 rows containing non-finite values (stat_density). 4.5.1.2 Discrete 4.5.1.3 Multivariate euro_regio_eu %&gt;% filter(year == 2015) %&gt;% ggplot() + geom_density(aes(x = lifeexp, y = stat(count), color = region)) + geom_density(aes(x = lifeexp, y = stat(count))) ## Warning: Removed 18 rows containing non-finite values (stat_density). ## Warning: Removed 18 rows containing non-finite values (stat_density). 4.5.2 Visualizing association 4.5.2.1 continuous vs. continuous # scatterplot # different symbols # fill versus color # white outline / overlap # dot chart # bubble chart # dot density map 4.5.2.2 continuous vs. discrete 4.5.2.3 discrete vs. discrete 4.5.3 Visualizing change 4.5.3.1 Lines 4.5.3.2 Slope 4.5.3.3 Connected dots 4.5.3.4 Waterfall 4.5.3.5 Bump 4.5.4 Visualizing surfaces 4.5.4.1 Contours 4.5.4.2 Heatmap geom_tile() draws rectangles at specified xy-positions. A common use-case is to visualize the value of a variable across a surface by coloring the rectangles according to value. This plot type is also known as a heatmap. Demographers refer to heatmaps as Lexis Surfaces if the surface is defined by period/cohort and age. Here’s an example showing Swedish age specific, logged death rates over time: load(&#39;data/hmd/hmd_swe.RData&#39;) swe &lt;- mutate(hmd_swe, nmx = nDx/nEx) ggplot(swe) + geom_tile(aes(x = period, y = age, fill = log(nmx))) geom_rect() is an alternative to geom_tile() but we need to specify all four corners of each rectangle we wish to draw. As each age and period group is a single year wide, we specify rectangles which have a width and height of one unit. ggplot(swe) + geom_rect(aes(xmin = period, xmax = period+1, ymin = age, ymax = age+1, fill = log(nmx))) Only specifying x and y position and omitting colour puts a grey rectangle at every xy position that appears in the data. The resulting plot gives us information about the period-ages where we have mortality data on Swedish females. By default the small rectangles have a width and height of 1 scale unit and are drawn over the mid-points of the corresponding x and y values. ggplot(swe) + geom_tile(aes(x = period, y = age), colour = &quot;white&quot;) + scale_x_continuous(breaks = 1800:1810) + scale_y_continuous(breaks = 100:110) + coord_equal(xlim = c(1800, 1810), ylim = c(100, 110)) Shifting the data by 0.5 in x and y aligns things neatly. ggplot(swe) + geom_tile(aes(x = period+0.5, y = age+0.5), colour = &quot;white&quot;) + scale_x_continuous(breaks = 1800:1810) + scale_y_continuous(breaks = 100:110) + coord_equal(xlim = c(1800, 1810), ylim = c(100, 110)) If our data does not come in 1 by 1 units we have to adjust the width and/or height of the rectangles. width and height are regular aesthetics and can be mapped to variables in the data. cod &lt;- read_csv(&#39;data/cod/cod.csv&#39;) ## Parsed with column specification: ## cols( ## Year = col_integer(), ## Age = col_integer(), ## AgeGr = col_character(), ## w = col_integer(), ## Sex = col_character(), ## COD = col_character() ## ) The Cause of Death data features age groups of different sizes (1, 4, or 5 years). This is how it looks like if we plot it without any regard to the size of the age groups. cod %&gt;% filter(Sex == &quot;Female&quot;) %&gt;% mutate(Year = Year + 0.5) %&gt;% ggplot() + geom_tile(aes(x = Year, y = Age), colour = &quot;white&quot;) Now we shift the rectangles away from the age midpoint and scale them in height according to the width of the age group. cod %&gt;% filter(Sex == &quot;Female&quot;) %&gt;% mutate(Year = Year + 0.5, Age = Age + w/2) %&gt;% ggplot() + geom_tile(aes(x = Year, y = Age, height = w), colour = &quot;white&quot;) If we use discrete axis (happens automatically if we supply a non-numeric variable to the x or y aesthetic) we loose any control over the placement of the age or period groups. They will be equally spaced along the axis. cod %&gt;% filter(Sex == &quot;Female&quot;) %&gt;% mutate(Year = Year + 0.5, Age = AgeGr) %&gt;% ggplot() + geom_tile(aes(x = Year, y = Age), colour = &quot;white&quot;) + coord_equal() Avoid character or factor variables as your period or age groups. Whenever possible go with numeric “Start of Interval” and “Interval Width” variables. 4.5.4.2.1 Sequential Colour Scales: Plotting Magnitudes If we plot magnitudes we would like to use a colour scale which has an intrinsic ordering to it. Scales that vary from dark to light are suitable and we call them “sequential”. scale_fill_brewer(type = &quot;seq&quot;) provides you with such a scale. breaks_nmx &lt;- c(0, 0.0001, 0.001, 0.01, 0.1, Inf) swe %&gt;% mutate(nmx_cut = cut(nmx, breaks = breaks_nmx)) %&gt;% ggplot() + geom_tile(aes(x = period, y = age, fill = nmx_cut), position = position_nudge(0.5, 0.5)) + scale_fill_brewer(type = &quot;seq&quot;) + guides(fill = guide_legend(reverse = TRUE)) + coord_equal() Continuous colour scales take the form of a smooth colour gradient. Getting the gradient to look like you want can be tricky. swe %&gt;% ggplot() + geom_tile(aes(x = period, y = age, fill = nmx)) + scale_fill_viridis_c() + coord_equal() Log transform the colour scale. swe %&gt;% ggplot() + geom_tile(aes(x = period, y = age, fill = nmx)) + scale_fill_viridis_c(trans = &#39;log10&#39;) + coord_equal() ## Warning: Transformation introduced infinite values in discrete y-axis Make high values dark and low values light. swe %&gt;% ggplot() + geom_tile(aes(x = period, y = age, fill = nmx)) + scale_fill_viridis_c(trans = &#39;log10&#39;, direction = -1) + coord_equal() ## Warning: Transformation introduced infinite values in discrete y-axis Rescale the colour gradient to increase contrast. swe %&gt;% ggplot() + geom_tile(aes(x = period, y = age, fill = nmx)) + scale_fill_viridis_c(trans = &#39;log10&#39;, direction = -1, values = c(0, 0.3, 0.4, 0.5, 0.6, 1)) + coord_equal() ## Warning: Transformation introduced infinite values in discrete y-axis Throw away data outside of the limits. swe %&gt;% ggplot() + geom_tile(aes(x = period, y = age, fill = nmx)) + scale_fill_viridis_c(trans = &#39;log10&#39;, direction = -1, values = c(0, 0.3, 0.4, 0.5, 0.6, 1), limits = c(0.001, 0.5)) + coord_equal() ## Warning: Transformation introduced infinite values in discrete y-axis Or instead squish the out-of-bounds data into the limits. swe %&gt;% ggplot() + geom_tile(aes(x = period, y = age, fill = nmx)) + scale_fill_viridis_c(trans = &#39;log10&#39;, direction = -1, values = c(0, 0.3, 0.4, 0.5, 0.6, 1), limits = c(0.001, 0.1), oob = scales::squish) + coord_equal() ## Warning: Transformation introduced infinite values in discrete y-axis 4.5.4.2.2 Divergent colour scales: Plotting Differences &amp; Proportions load(&#39;data/hmd/hmd.RData&#39;) breaks_prop_nmx &lt;- c(0, 0.3, 0.5, 0.7, 0.9, 1.1, 1.3, 1.5, 1.7, Inf) hmd %&gt;% filter(country == &#39;SWE&#39;) %&gt;% select(sex, period, age, nmx) %&gt;% spread(sex, nmx) %&gt;% mutate(sex_ratio = Male/Female, sex_ratio_disc = cut(sex_ratio, breaks_prop_nmx)) %&gt;% ggplot() + geom_tile(aes(x = period, y = age, fill = sex_ratio_disc)) + scale_fill_brewer(type = &quot;div&quot;, palette = 5) + guides(fill = guide_legend(reverse = TRUE)) + coord_equal() Continuous variant. hmd %&gt;% filter(country == &#39;SWE&#39;) %&gt;% select(sex, period, age, nmx) %&gt;% spread(sex, nmx) %&gt;% mutate(sex_ratio = Male/Female) %&gt;% ggplot() + geom_tile(aes(x = period, y = age, fill = sex_ratio)) + # takes 6 colours from a brewer palette and interpolates scale_fill_distiller(type = &quot;div&quot;, palette = &quot;RdBu&quot;, trans = &quot;log2&quot;, limits = c(0.5, 2), direction = 1, oob = scales::squish) + coord_equal() 4.5.4.2.3 Qualitative colour scales: Plotting Group Membership cod %&gt;% mutate(Year = Year + 0.5, Age = Age + w/2) %&gt;% ggplot() + geom_tile(aes(x = Year, y = Age, height = w, fill = COD)) + coord_equal() + facet_wrap(~Sex, ncol = 2) + scale_fill_manual(&quot;Dominant cause of death&quot;, values = c(&quot;Infections&quot; = &quot;#63C46A&quot;, &quot;Neoplasms&quot; = &quot;#E7CC60&quot;, &quot;Circulatory diseases&quot; = &quot;#FF4B56&quot;, &quot;External&quot; = &quot;#C463AF&quot;, &quot;Other&quot; = &quot;#969696&quot;)) 4.5.4.3 Tables hmd %&gt;% filter(country == &#39;DEUTE&#39;, sex == &#39;Female&#39;, (period %% 5) == 0, (age %% 5) == 0) %&gt;% ggplot(aes(x = period, y = age, alpha = lx, size = lx)) + geom_text(aes(label = ex%/%10), family = &#39;mono&#39;, fontface = &#39;bold&#39;, show.legend = FALSE) + scale_x_continuous(breaks = seq(1900, 2010, 10)) + scale_y_continuous(breaks = seq(0, 110, 10)) + theme_bw() + coord_equal() + labs(title = &#39;Decades left to live.&#39;) hmd %&gt;% filter(country %in% c(&#39;DEUTE&#39;, &#39;DEUTW&#39;), sex == &#39;Female&#39;, (period %% 5) == 0, (age %% 5) == 0) %&gt;% select(country, period, age, ex) %&gt;% spread(country, ex) %&gt;% mutate(d_ex = DEUTE - DEUTW) %&gt;% ggplot(aes(x = period, y = age)) + geom_text(aes(label = d_ex%/%1, alpha = abs(d_ex%/%1)), family = &#39;mono&#39;, fontface = &#39;bold&#39;, show.legend = FALSE) + scale_x_continuous(breaks = seq(1900, 2010, 10)) + scale_y_continuous(breaks = seq(0, 110, 10)) + theme_bw() + coord_equal() + labs(title = &#39;East-West German difference\\nin years of remaining life-expectancy.&#39;) 4.5.5 Excercise: Chart type vocabulary Using ggplot2, plot a population pyramid using data of your choice. Calculate the differences of Danish and Swedish remaining male life-expectancies by period and age. Visualize the result as a Lexis surface with a discrete divergent color scale. The choice of breaks is up to you. 4.6 Polish your plot for publication 4.6.1 Highlight 4.6.2 Annotate 4.7 Maps 4.8 Networks Wilkinson, L. (1999). Dot Plots. The American Statistician, 53(3), 276. https://doi.org/10.2307/2686111↩ you can find out about the computed variables by looking into the help page of a geom.↩ "]
]
